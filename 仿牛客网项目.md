# 仿牛客网项目

## 第一章，初识Spring Boot，开发社区首页

### 第一节，课程介绍

- 学会主流的web开发技术和框架

- 积累一个真实的web项目的开发经验

- 掌握热点面试题的答题策略


#### 1，主页面

<img src="D:\Typora\File\nowcode_community\image-20220606142928453.png" alt="image-20220606142928453" style="zoom:67%;" />

#### 2，技术架构

**Spring Boot 、Spring、Spring MVC、MyBatis、Redis、Kafka、Elasticsearch、Spring Security、Spring Actuator**

#### 3，开发环境

- 构建工具：Maven
- 集成开发工具：IDEA
- 数据库：MySQL、Redis
- 应用服务器：Tomcat
- 版本控制工具：Git

### 第二节，搭建环境

第一步：下载安装Maven。需要修改settings.xml，出现下面的情况就表示已经安装成功了。

<img src="D:\Typora\File\nowcode_community\image-20220606144746502.png" alt="image-20220606144746502" style="zoom:80%;" />

第二步：安装IDEA

第三步：使用Spring Initializr来创建Spring Boot 工程。使用网站：https://start.spring.io/

<img src="D:\Typora\File\nowcode_community\image-20220606145802165.png" alt="image-20220606145802165" style="zoom:80%;" />

然后启动主类：打开:localhost:8080，然后如果看到了以下页面就表示配置成功了

<img src="D:\Typora\File\nowcode_community\image-20220606150825976.png" alt="image-20220606150825976" style="zoom:80%;" />

添加如下的依赖：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.20</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.2.0</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-mail</artifactId>
        <version>2.6.3</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.12.0</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha -->
    <dependency>
        <groupId>com.github.penggle</groupId>
        <artifactId>kaptcha</artifactId>
        <version>2.3.2</version>
    </dependency>
</dependencies>
```

​		此时我们来测试一下SpringMVC是否是可用的，我们只需要在controller类中返回一个字符串，其中如果我们需要在页面上面显示返回的字符串，那么我们需要在这个方法的上面加上@ResponseBody就是表示在controller中的return中的字符串返回到页面上面，如果不加的话，那么就会去找由这个字符串组成的html页面，如果找不到的话，那么就会报404的错误。

```java
@Controller
@RequestMapping("/alpha")
public class AlphaController {

    @RequestMapping("/hello")
    @ResponseBody
    public String sayHello() {
        return "Hello Spring Boot.";
    }
}
```

加上ResponseBody的时候显示的页面

![image-20220613233733194](D:\Typora\File\nowcode_community\image-20220613233733194.png)

不加ResponseBody的时候显示的页面

![image-20220613233816792](D:\Typora\File\nowcode_community\image-20220613233816792.png)

**controller和rescontroller的区别：**这两个注解都是用来表示Spring某个类的是否可以接收HTTP请求。

@Controller：标识一个Spring类是SpringMVC controller处理器,

@RestController：@RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。@Controller类中的方法可以直接通过返回String跳转到jsp、ftl、html等模版页面。在方法上加@ResponseBody注解，也可以返回实体对象。@RestController类中的所有方法只能返回String、Object、Json等实体对象，不能跳转到模版页面。@RestController中的方法如果想跳转页面，则用ModelAndView进行封装

### 第三节，Spring入门

参考网站：https://spring.io/

**bean就是由Spring来管理的java对象**

#### 1，Spring Framework中的组件

核心Spring Core（IOC、AOP）

数据库Spring Data Access(Transactions、Spring MyBatis)

网页开发Web Servlet（Spring MVC）

Integration（Email、Scheduling、AMQP、Security）

#### 2，Spring IOC

Inversion of Control控制反转：是一种面向对象编程的设计思想

Dependency Injection依赖注入：是IOC思想的实现方式

IoC ContainerIoC容器：是实现依赖注入的关键，本质上是一个工厂

#### 3，测试Spring

##### ①，来查看以下Spring容器是什么

```java
@SpringBootTest
//表示以该配置类来启动主程序
@ContextConfiguration(classes = CommunityApplication.class)
class CommunityApplicationTests implements ApplicationContextAware {

	private ApplicationContext applicationContext;

	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}

	@Test
	public void testApplicationContext(){
		System.out.println(applicationContext);
	}
}

运行结果：
    //表示Spring容器时存在的，可以通过这个容器来获取bean
    org.springframework.web.context.support.GenericWebApplicationContext@538613b3, started on Mon Jun 06 15:37:45 CST 2022
```

##### ②，通过Spring容器来获取数据访问层的bean

```java
//接口：
public interface AlphaDao {

    String select();
}

实现类：
//注意，这里需要注意的是需要使用数据@Repository或者是@Mapper注解来标注，表示再Spring来启动的时候会扫描这个类来进行注入。
//后面的"alphaImpl"表示是按照名称来进行注入的时候，默认的是类名的首字母小写
//在实际的生产过程中，我们一般都不会使用dao层的实现类，一般都是使用的接口，然后编写Mapper.xml的sql语句的配置文件
//如果一个接口有两个或者多个实现类的话，那么我们可以使用@Primary来实现这个接口的优先级比骄高，一般都是这个优先。如果需要来访问
//特定的接口，我们可以使用@Qualifier()来根据名称来判断，这个时候就不会产生歧义了。
@Repository("alphaImpl")
public class AlphaDaoImpl implements AlphaDao{

    @Override
    public String select() {
        return "mybatis";
    }
}

测试类：
@Test
	void contextLoads() {
		System.out.println(applicationContext);
    	//通过类型来获取java对象，这里使用接口或者实现类都是可以的，相当于注解@Autowired
		AlphaDao bean = applicationContext.getBean(AlphaDao.class);
        //然后通过对象来调用实例方法
		System.out.println(bean.select());
    	//通过名称来进行注入,相当于@Qualifier("alphaImpl")
		AlphaDao alphaImpl = applicationContext.getBean("alphaImpl", AlphaDaoImpl.class);
		System.out.println(alphaImpl.select());
	}

运行结果：
mybatis
mybatis
```

##### ③，通过Spring容器来获取Service层的bean

```java
//service层：
@Service
//@Scope("prototype")
public class AlphaService {

    @Autowired
    private AlphaDao alphaDao;

    public AlphaService(){
        System.out.println("实例化AlphaService");
    }

    //在对象加载完依赖注入后执行
    @PostConstruct
    public void init(){
        System.out.println("初始化AlphaService");
    }

    @PreDestroy
    public void destroy(){
        System.out.println("销毁AlphaService");
    }

    public String find(){
        return alphaDao.select();
    }
}

测试类：
@Test
void testBeanManager(){
    AlphaService bean = applicationContext.getBean(AlphaService.class);
    System.out.println(bean);
    bean = applicationContext.getBean(AlphaService.class);
    System.out.println(bean);
}

//运行结果：
//com.nowcoder.community.service.AlphaService@32b112a1
//com.nowcoder.community.service.AlphaService@32b112a1
//分析：因为javabean默认的都是单实例的，因此其创建的对象的内存地址都是一样的，如果需要设置的话，那么就在Service层使用@Scope("prototype")来设置多实例的或者是sessin或者request
```

##### ④，通过Spring容器来获取配置类的bean

```java
//配置类
//需要加入@Configuration来表示配置类
@Configuration
public class AlphaConfig {

    //将配置类来实例化
    //使用配置类的时候，方法名就是这个bean的名字即simpleDateFormat
    @Bean
    public SimpleDateFormat simpleDateFormat(){
        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
    }
}

//测试类:
@Test
void testBeanConfig(){
    SimpleDateFormat bean = applicationContext.getBean(SimpleDateFormat.class);
    System.out.println(bean.format(new Date()));
}

运行结果：
2022-06-06 16:11:56 593
```

##### ⑤，通过自动注入的方式来获取Dao层的bean

（其他层的都是可以的）

```java
//依赖注入
@Autowired
private AlphaDao alphaDao;

//测试类：
@Test
void testDI(){
    System.out.println(alphaDao.select());
}

运行结果：
mybatis
```

⑥模拟业务之间的实际的调用：controller调用service，service调用dao

我们在编写代码的时候，即使是有实现类的，但是我们注入的依然还是接口，如果这个接口只用一个实现类的话，我们就可以直接使用@Autowired来实现依赖注入，但是如果有两个或者两个以上的话，那么我们根据类型来调用就不行了，这个时候我们就需要在注解上面加上@Qualifier来实现除了类型还可以使用名称来调用，这个名称和实现类上面的名称是一样的，实现类如果不写的话，那么就是默认的是类名的首字母的小写。

```java
//dao层：
@Repository
public class AlphaDaoImpl implements AlphaDao{

    @Override
    public String select() {
        return "mybatis";
    }
}

//service层：
@Service
public class AlphaService {

    @Autowired
    private AlphaDao alphaDao;

    public String find(){
        return alphaDao.select();
    }
}

controller层：
@Controller
@RequestMapping("/alpha")
public class AlphaController {
    @Autowired
    private AlphaService alphaService;

    @RequestMapping("/data")
    @ResponseBody
    public String getData(){
        return alphaService.find();
    }
}
然后我们启动浏览器；输入：http://localhost:8080/community/alpha/data，就可以在页面上面看到mybatis，这就表示成功
```

**通过Spring容器来获取bean和使用Autowired来自动注入和通过new对象之间的区别是什么？**

```java
①xxx s = new xxx();

②xxx s = application.getBean(xxx.class);

③@Autowired
private xxx s;

这三者的区别是什么:
第一种方式是通过new对象的方式来实现的，这个时候对象之间的耦合度太高了
第二种方式也是我们主动去获取bean容器中的bean，这中方式也不是很方便
第三种方式是我们希望spring容器将xxx类型的bean给到s，这样的话s就表示是xxx类型的bean了，这样的话我们就可以来调用xxx类型的变量和方法了，我们也是可以将这个bean放在构造器或者set方法上面来实现注入的，但是一般都是放在属性上面，这样更加方便。
```

**我们在使用@Autowired可能会因为类型而产生冲突，但是我们不使用@Qualifier()来根据名称来自动注入对象？**

​		我们现在都是习惯使用@Autowired来实现依赖注入，只有当@Autowired出现类型冲突的时候，我们才会选择配合着@Qualifier()来使用。

**我们在写数据访问层的时候为什么不需要写接口的实现类？**





### 第四节，SpringMVC入门

#### 1，HTTP协议

参考网站：https://developer.mozilla.org/zh-CN/docs/Web/Http

用于传输HTML等内容的应用层协议，规定了浏览器和服务器之间是如何通信以及通信时的数据格式。

<img src="D:\Typora\File\nowcode_community\image-20220606164458960.png" alt="image-20220606164458960" style="zoom:67%;" />

**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的[应用层](https://en.wikipedia.org/wiki/Application_Layer)协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的[客户端 - 服务端模型](https://en.wikipedia.org/wiki/Client–server_model)，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。HTTP 是[无状态协议](http://en.wikipedia.org/wiki/Stateless_protocol)，这意味着服务器不会在两个请求之间保留任何数据（状态）。尽管通常基于 TCP/IP 层，但它可以在任何可靠的[传输层](https://zh.wikipedia.org/wiki/传输层)上使用，也就是说，该协议不会像 UDP 那样静默的丢失消息。[RUDP](https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol)——作为 UDP 的可靠化升级版本——是一种合适的替代选择。

当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步：

1. 打开一个 TCP 连接：TCP 连接被用来发送一条或多条请求，以及接受响应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的 TCP 连接连向服务端。

2. 发送一个 HTTP 报文：HTTP 报文（在 HTTP/2 之前）是语义可读的。在 HTTP/2 中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。

   ```html
   GET / HTTP/1.1
   Host: developer.mozilla.org
   Accept-Language: fr
   ```

3. 读取服务端返回的报文信息：

   ```html
   HTTP/1.1 200 OK
   Date: Sat, 09 Oct 2010 14:28:02 GMT
   Server: Apache
   Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
   ETag: "51142bc1-7449-479b075b2891b"
   Accept-Ranges: bytes
   Content-Length: 29769
   Content-Type: text/html
   
   <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
   ```

4. 关闭连接或者为后续请求重用连接。

当 HTTP 流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而 HTTP 流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP 流水线已被在有多请求下表现得更稳健的 HTTP/2 的帧所取代。

HTTP请求的格式：

![image-20220614104425516](D:\Typora\File\nowcode_community\image-20220614104425516.png)

HTTP响应的格式：

![image-20220614104502214](D:\Typora\File\nowcode_community\image-20220614104502214.png)



这是我们在网页的工具上面看到的请求和响应的数据

<img src="D:\Typora\File\nowcode_community\image-20220606170021947.png" alt="image-20220606170021947" style="zoom:67%;" />



<img src="D:\Typora\File\nowcode_community\image-20220606165751471.png" alt="image-20220606165751471" style="zoom:67%;" />

解释说明：这里出现了多个请求的原因是在第一个http请求以后，服务端会给客户端响应一个HTML页面，这个页面里面可能会包含有多个css样式或者时javaScript，这些文件同样也是会需要去请求服务器端的，因此我们会看到有很多的css和js的请求。

#### 2，MVC的三层架构

三层架构：表现层（controller）、业务层（service）、数据访问层（dao）

MVC：Model（模型层）、View（视图层）、Controller（控制层）

核心组件：前端控制器（DispatcherServlet）

​		这里需要注意的是我们在编写程序的时候一般都是使用的三层架构的形式，但是这个三层架构和MVC的三层架构是不一样的。MVC的三层架构是集中的三层架构的表现层的，如下图所示：

​		项目的三层架构说的是service调用dao，controller调用service。但是在MVC的三层架构说的是用户的页面上的操作先被controller来调用service，然后再调用dao，将最后的结果再传回controller，由model来将结果显示到view页面的过程。

<img src="D:\Typora\File\nowcode_community\image-20220606185700794.png" alt="image-20220606185700794" style="zoom:67%;" />

#### 3，前端控制器DispatcherServlet的运行流程

<img src="D:\Typora\File\nowcode_community\image-20220606191118250.png" alt="image-20220606191118250" style="zoom: 67%;" />

流程：用户请求会通过前端控制器根据请求的路径找到对应的controller（当路径相同的时候，请求方式不同也是可以的），controller会将数据封装到model里面返回给前端控制器，下一步就是前端控制器将model中的数据和view模板进行组合，将模板中的一些特殊符号用model中的数据进行替换，这样就得到了一个动态的页面，将该页面通过前端控制器返回给浏览器即完成了依次请求和响应。

#### 4，Thymeleaf模板引擎

参考网站：https://www.thymeleaf.org/

模板引擎：生成动态的HTML

Thymeleaf：倡导自然模板，即以HTML文件为模板

常用语法：标准表达式、判断与循环、模板的布局

<img src="D:\Typora\File\nowcode_community\image-20220606192150876.png" alt="image-20220606192150876" style="zoom:67%;" />

#### 5，代码演示

##### ①底层原理

```properties
首先我们需要再application.properties配置文件中将thymeleaf中的缓存关闭，这样保证了我们在修改页面了以后可以及时看到页面的变化
# ThymeleafProperties
spring.thymeleaf.cache=false
```

```java
//下一步，编写java代码：
@RequestMapping("/http")
public void http(HttpServletRequest request, HttpServletResponse response){

    //获取请求的第一行数据
    System.out.println(request.getMethod());
    System.out.println(request.getServletPath());
    //获取请求的消息头
    Enumeration<String> enumeration = request.getHeaderNames();
    while (enumeration.hasMoreElements()){
        String name = enumeration.nextElement();
        String value = request.getHeader(name);
        System.out.println(name + " : " + value);
    }
    //获取请求的参数
    System.out.println(request.getParameter("code"));

    //返回响应数据
    response.setContentType("text/html;charset=utf-8");
    try
            //这样写的话，可以让其自动关闭，不需要通过finally来进行关闭了
            (PrintWriter writer = response.getWriter()
            ) {
        //这里只是演示html中的内容，并不是显示一个完整的网页
        //这里是底层的实现，我们在实际的开发过程中是不会涉及到这个的
        writer.write("<h1>牛客网</h1>");
    } catch (IOException e) {
        e.printStackTrace();
    }
}

```

然后我们通过网页就可以看到以下内容：

<img src="D:\Typora\File\nowcode_community\image-20220606193826573.png" alt="image-20220606193826573" style="zoom:67%;" />

下面我们来看一下控制台：

```java
GET     ====》request.getMethod()
/alpha/http    ====》request.getServletPath()
    
//获取请求的消息头
host : localhost:8080
connection : keep-alive
sec-ch-ua : " Not A;Brand";v="99", "Chromium";v="102", "Microsoft Edge";v="102"
sec-ch-ua-mobile : ?0
sec-ch-ua-platform : "Windows"
upgrade-insecure-requests : 1
user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36 Edg/102.0.1245.33
accept : text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
sec-fetch-site : none
sec-fetch-mode : navigate
sec-fetch-user : ?1
sec-fetch-dest : document
accept-encoding : gzip, deflate, br
accept-language : zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
cookie : ticket=0a8298c84311499eb9c9540e7985c82e; Idea-37ad6e9e=59732e51-a1c7-43ba-9196-f7dc5eeb2ae0


//request.getParameter("code")表示在浏览器地址栏上面输入的参数
123
```

##### ②GET请求

我们在向浏览器获取数据的时候一般都是使用的GET请求，而且默认的也是GET请求：

```java
//GET请求 浏览器向服务器查询请求，进行分页显示
//这里我们明确get请求，这样post请求就进不来了，如果不写的话，虽然默认的是get请求，但是post请求也是可以进来的
@RequestMapping(path = "/students",method = RequestMethod.GET)
//该注解的作用的让return返回的数据直接显示在页面上面，如果不加这个注解的话，那么就会去找以这个开始的页面，找不到的话就返回500了
@ResponseBody
public String getStudents(
    //这也是一种传递参数的方式，我们在浏览器的地址栏上面输入的参数会对应到这里来
    //如果填写了参数，就按照参数来，如果没有参数的话，那么我们就使用默认值
    @RequestParam(name = "current",required = false,defaultValue = "1") int current,
    @RequestParam(name = "limit",required = false,defaultValue = "10") int limit
    ){
    System.out.println(current);
    System.out.println(limit);
    return "some students";
}
```

然后我们通过网页就可以看到以下内容：

<img src="D:\Typora\File\nowcode_community\image-20220606195418022.png" alt="image-20220606195418022" style="zoom: 80%;" />

下面我们来看一下控制台：

```java
3
999
```

使用参数的另外一种方式：

```java
@RequestMapping(path = "student/{id}",method = RequestMethod.GET)
@ResponseBody
public String getStudent(@PathVariable("id") int id){
    System.out.println(id);
    return "a student";
}
```

然后我们通过网页就可以看到以下内容：

<img src="D:\Typora\File\nowcode_community\image-20220606195830422.png" alt="image-20220606195830422" style="zoom:80%;" />

下面我们来看一下控制台：

```java
102
```

**这里需要注意以下的是两种方式不一样，一个是使用？，一个是使用/**

这个是后端的数据传递给前端

第一步：创建html页面：

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>测试1</title>
</head>
<body>
<p th:text="${message}"></p>
<!--<p th:text="${list.map.username}">
<p th:text="${list.map.age}">-->
<p th:text="${map.username}">
<p th:text="${map.age}">
</body>
</html>
```

第二步：编写java代码：

```java
@RequestMapping(path = "/test1",method = RequestMethod.GET)
public String test1(Model model){
    Map<String,Object> map = new HashMap<>();
    List<Map<String,Object>> list = new ArrayList<>();
    model.addAttribute("message","helloWorld");

    map.put("username","zhangsan");
    map.put("age",999);
    list.add(map);
    model.addAttribute("list",list);
    model.addAttribute("map",map);
    return "html/html1";
}
```

页面显示：

![image-20220614142426159](D:\Typora\File\nowcode_community\image-20220614142426159.png)

##### ③POST请求

我们向服务器提交数据的时候，有很多种方式，一般都是通过POST请求来进行实现的。我们向服务器提交数据的时候，一般都是通过form表单来进行的。

这个是前端的数据传递给后端

第一步：创建一个html页面：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>增加学生</title>
</head>
<body>
    <!--我们可以通过这个表单将从页面上面的数据传递到后端，但是前提是数据的字段必须是对应的-->
<form method="post" action="/community/alpha/student">
  <p>
    姓名 : <input type="text" name="name" />
  </p>
  <p>
    年龄 : <input type="text" name="age" />
  </p>
  <p>
          <input type="submit" value="保存" />
  </p>
</form>
</body>
</html>
```

第二步：编写java代码：

```java
//POST请求 浏览器向服务器提交请求
@RequestMapping(path = "/student",method = RequestMethod.POST)
@ResponseBody
public String saveStudent(String name,int age){
    System.out.println(name);
    System.out.println(age);
    return "success";
}
```

第三步：打开页面，填写数据

<img src="D:\Typora\File\nowcode_community\image-20220606201151466.png" alt="image-20220606201151466" style="zoom:80%;" />

在点击了保存以后显示的页面

<img src="C:\Users\20948\AppData\Roaming\Typora\typora-user-images\image-20220606201315870.png" alt="image-20220606201315870" style="zoom:80%;" />

来看看控制台：

```java
郭定伟
21
```

分析：

<img src="D:\Typora\File\nowcode_community\image-20220606201459608.png" alt="image-20220606201459608" style="zoom: 67%;" />

我们在页面点击了保存按钮以后，前端控制器就会根据action种的路径来找controller种的路径，然后进行相应的操作。这时如果后端需要接收到前端传过来的参数，那么前后端的字段名必须是对应的。也就是说，后端的path必须和前端的action对应，前后端的字段也必须是对应的。

这个是后端的数据传递给前端

java代码：

```java
//响应HTML数据
@RequestMapping(path = "/teacher",method = RequestMethod.GET)
public ModelAndView getTeacher(){
    ModelAndView mav = new ModelAndView();
    mav.addObject("name","张三");
    mav.addObject("age",30);
    mav.setViewName("/demo/view");
    return mav;
}
```

前端页面：（需要放在templates目录下，并且该目录是不需要写的），名称叫view.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Teacher</title>
</head>
<body>
<p th:text="${name}"></p>
<p th:text="${age}"></p>
</body>
</html>
```

前端页面的显示：

<img src="D:\Typora\File\nowcode_community\image-20220606201954556.png" alt="image-20220606201954556" style="zoom:67%;" />

<img src="D:\Typora\File\nowcode_community\image-20220606203021113.png" alt="image-20220606203021113" style="zoom:67%;" />

后端的数据传递给前端的另外一种方式，而且这种方式是更加常见的，我们在实际的开发过程中一般也是这样使用的

java代码：

```java
@RequestMapping(path = "/school",method = RequestMethod.GET)
public String getSchool(Model model){
    model.addAttribute("name","奥特曼");
    model.addAttribute("age",999999);
    return "/demo/view";
}
```

前端页面和上面的一样，不需要变

前端页面的显示：

<img src="D:\Typora\File\nowcode_community\image-20220606202141938.png" alt="image-20220606202141938" style="zoom:67%;" />

相应JSON类型的数据：

```java
//响应JSON类型的数据
//JSON类型的数据一般都是在异步的情况下使用的，比如我们在注册b站的时候我们输入用户名，当该输入框失去焦点的时候就会去访问
//数据库，看看该用户名是否被占用，这个时候我们并没有提交，但是它依然会去查询数据库的
//Java对象 -> JSON字符串 -> JS对象
@RequestMapping(path = "/emp",method = RequestMethod.GET)
@ResponseBody
public Map<String,Object> getEmp(){
    Map<String,Object> emp = new HashMap<>();
    emp.put("name","张三");
    emp.put("age",21);
    emp.put("salary",8000);
    return emp;
}

或者说的话可以是如下的代码：
@RequestMapping(path = "/emps", method = RequestMethod.GET)
@ResponseBody
public List<Map<String, Object>> getEmps() {
    List<Map<String, Object>> list = new ArrayList<>();

    Map<String, Object> emp = new HashMap<>();
    emp.put("name", "张三");
    emp.put("age", 23);
    emp.put("salary", 8000.00);
    list.add(emp);

    emp = new HashMap<>();
    emp.put("name", "李四");
    emp.put("age", 24);
    emp.put("salary", 9000.00);
    list.add(emp);

    emp = new HashMap<>();
    emp.put("name", "王五");
    emp.put("age", 25);
    emp.put("salary", 10000.00);
    list.add(emp);
    return list;
}
```

前端页面显示：

<img src="D:\Typora\File\nowcode_community\image-20220606202926421.png" alt="image-20220606202926421" style="zoom:67%;" />





##### ④static目录和templates目录的区别



**@PathVariable与@RequestParam的区别是什么？**



**@GetMapping和@RequestMapping的区别是什么？**



**get请求和post请求的区别是什么？**



**servlet和jsp的区别是什么？**



**服务器，浏览器，前端，后端的区别是什么？**







### 第五节，MyBatis入门

参考文档：https://mybatis.org/mybatis-3/zh/index.html  mybatis手册

http://mybatis.org/spring/  mybatis整合Spring的手册

前提：需要安装mysql以及mysql的桌面端

<img src="D:\Typora\File\nowcode_community\image-20220607141320214.png" alt="image-20220607141320214" style="zoom:67%;" />

Navicat for MySQL

<img src="D:\Typora\File\nowcode_community\image-20220607141438092.png" alt="image-20220607141438092" style="zoom: 50%;" />

#### 1,MyBatis的核心组件

SqlSessionFactory：用于创建SqlSession的工厂类

SqlSession：MyBatis的核心组件，用于向数据库执行SQL

主配置文件:XML配置文件，可以对MyBatis的底层行为做出详细的配置

Mapper接口：就是DAO接口，在MyBatis中习惯性的称为Mapper

Mapper映射器：用于编写SQL，并将SQL和实体类映射的组件，采用XML、注解均可实现

#### 2，示例

使用MyBatis对用户表进行CRUD操作

第一步：加入依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.20</version>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.12</version>
    <scope>provided</scope>
</dependency>
```

第二步：在application.properties配置文件中添加MyBatis的配置文件

```properties
# DataSourceProperties
# mysql的驱动
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# mysql的连接地址，表示连接哪个数据库，mysql8以后是需要自己去配置时区的
spring.datasource.url=jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&useSSL=false&serverTimezone=Hongkong
# mysql的用户名
spring.datasource.username=root
# mysql的密码
spring.datasource.password=
# 连接池的类型，现在常用的数据库连接池一般有DBCP、C3p0、Druid等
spring.datasource.type=com.zaxxer.hikari.HikariDataSource
# 最大连接数
spring.datasource.hikari.maximum-pool-size=15
# 最小连接数
spring.datasource.hikari.minimum-idle=5
# 超时等待时间，当超过这个时间还没有连接成功就放弃连接
spring.datasource.hikari.idle-timeout=30000

# MybatisProperties
# resources目录下的编写sql语句的文件，在resources目录下有一个mapper目录，这个目录下面的以.xml结尾的文件都可以被映射到
mybatis.mapper-locations=classpath:mapper/*.xml
# 用来扫描实体类
mybatis.type-aliases-package=com.nowcoder.community.entity
# 表示主键自增
mybatis.configuration.useGeneratedKeys=true
# 表示表中的数据一般是下划线的方式，而实体类中的属性是使用的驼峰命令的方式的，这个设置可以让他们相互对应
mybatis.configuration.mapUnderscoreToCamelCase=true
```

第三步：编写java代码

##### ①实体类：（User类）

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class User {

    //用户id
    private int id;
    //用户名
    private String username;
    //用户密码
    private String password;
    //加密盐
    private String salt;
    //邮箱
    private String email;
    //用户角色
    private int type;
    //登录状态
    private int status;
    //激活码
    private String activationCode;
    //头像的访问路径
    private String headerUrl;
    //用户创建时间
    private Date createTime;
    
}

```

##### ②dao层（UserMapper接口）

```java
//这两个注解其实都是可以的，只不过我们在使用mybatis的时候习惯使用的是Mapper注解
//作用都是让spring来管理这个bean
//@Repository
@Mapper
public interface UserMapper {

    /**
     * 根据id进行查询用户
     * @param id 传入的参数是用户id（条件）
     * @return 返回值是这个用户对象（里面都包含有用户属性）
     */
    User selectById(int id);

    /**
     * 根据用户名查询用户
     * @param username 传入的参数是用户名
     * @return 返回值是这个用户对象
     */
    User selectByName(String username);

    /**
     * 根据邮箱查询用户
     * @param email 传入的参数是邮箱
     * @return 返回值是这个用户对象
     */
    User selectByEmail(String email);

    /**
     * 插入用户（每次注册的时候都会进行用户的增加）
     * @param user 传入的参数是用户对象
     * @return 返回值是插入成功的条数
     */
    int insertUser(User user);

    /**
     * 更新登录状态
     * @param id 传入的参数是用户的id（条件）
     * @param status 传入的参数是用户需要修改的状态
     * @return 返回值是更新状态成功的条数
     */
    int updateStatus(int id,int status);

    /**
     * 更新用户的头像（就是用户来更新头像）
     * @param id 传入的参数是用户的id（条件）
     * @param headerUrl 传入的参数是用户的头像地址
     * @return 返回值是更新头像成功的条数
     */
    int updateHeader(int id,String headerUrl);

    /**
     * 修改密码
     * @param id
     * @param password
     * @return
     */
    int updatePassword(int id,String password);

}
```

**@Mapper与@Repository之间的区别：**@Mapper和@Repository都是作用在dao层接口，使得其生成代理对象bean，交给spring 容器管理。@Repository需要在Spring中配置扫描地址，然后生成Dao层的Bean才能被注入到Service层中，@Mapper不需要配置扫描地址，通过xml里面的namespace里面的接口地址，生成了Bean后注入到Service层中。因此，**我们在SpringBoot中@Mapper用的比较多**。

##### ③编写sql语句（user-mapper.xml文件）

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--这里的名称空间就是对应的mapper类（就是相应的dao的方法）-->
<mapper namespace="com.nowcoder.community.dao.UserMapper">

    <!--在这里定义一个sql字段，在后面进行引入，这样得话就不需要每次都写这些字段了，只需要通过include来进行引入即可-->
    <sql id="selectFields">
        id,username,password,salt,email,type,status,activation_code,header_url,create_time
    </sql>

    <sql id="insertFields">
        username,password,salt,email,type,status,activation_code,header_url,create_time
    </sql>
    <!--根据id进行查询,返回值就是方法的返回值，如果返回值是一个List集合，那么返回值就是泛型的类型-->
    <!--这里的id就是方法名-->
    <!--User selectById(int id);-->
    <select id="selectById" resultType="User">
        select <include refid="selectFields"/>
        from user
        where id = #{id}
    </select>

    <!--根据用户名查询-->
    <!--User selectByName(String username);-->
    <select id="selectByName" resultType="User">
        select <include refid="selectFields"/>
        from user
        where username = #{username}
    </select>

    <!--根据邮箱查询-->
    <!--User selectByEmail(String email);-->
    <select id="selectByEmail" resultType="User">
        select <include refid="selectFields"/>
        from user
        where email = #{email}
    </select>

    <!--插入用户-->
    <!--int insertUser(User user);-->
    <!--字段id对应的属性是什么，这里的id就是User类里面的id-->
    <!--这里要注意的是values后面的数据是属性，所以要对应好实体类User中的字段-->
    <insert id="insertUser" parameterType="User" keyProperty="id">
        insert into user (<include refid="insertFields" />)
        values (#{username},#{password},#{salt},#{email},#{type},#{status},#{activationCode},#{headerUrl},#{createTime})
    </insert>

    <!--更新状态-->
    <!--int updateStatus(int id,int status);-->
    <update id="updateStatus">
        update user set status = #{status} where id = #{id}
    </update>


    <!--更新用户头像-->
    <!--因为在这里我们返回的是int简单类型，因此，我们也可以不用写返回值类型-->
    <!--int updateHeader(int id,String headerUrl);-->
    <update id="updateHeader">
        /*前面的header_url是数据库中的字段，而headerUrl是我们传入的参数中（实体类）的字段*/
        update user set header_url = #{headerUrl} where id = #{id}
    </update>


    <!--修改密码-->
    <!--int updatePassword(int id,String password);-->
    <update id="updatePassword">
        update user set password = #{password} where id = #{id}
    </update>
</mapper>
```

​        这里我们需要说明的一点是<sql>这个标签，它的目的可以创建一些字段，然后在后序的编写的sql语句中可以提高<include>来实现复用的功能。

<img src="D:\Typora\File\nowcode_community\image-20220607154613581.png" alt="image-20220607154613581" style="zoom:67%;" />

④，在测试类中测试数据：（MapperTests类）

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class MapperTests {

    //依赖注入
    @Autowired
    private UserMapper userMapper;

    //数据查询
    //提供id，姓名，邮件来查询用户
    @Test
    public void selectUser(){
        User user = userMapper.selectById(101);
        System.out.println(user);

        user = userMapper.selectByName("liubei");
        System.out.println(user);

        user= userMapper.selectByEmail("nowcoder101@sina.com");
        System.out.println(user);
    }

    //插入数据
    @Test
    public void insertUser(){
        User user = new User();
        user.setUsername("111");
        user.setPassword("123222456");
        user.setSalt("003330");
        user.setEmail("2q44422323q.com");
        user.setType(1);
        user.setStatus(1);
        user.setActivationCode("132323");
        user.setHeaderUrl("423256");
        user.setCreateTime(new Date());
        int i = userMapper.insertUser(user);
        System.out.println(i);
    }

    //更新数据
    @Test
    public void updateUser(){
        int i = userMapper.updateStatus(137, 1);
        int i1 = userMapper.updateHeader(137, "9090902");
        int i2 = userMapper.updatePassword(137, "65432221");
        System.out.println(i+":"+i1+":"+i2);
    }
}
```

运行结果：

查询数据：

```
User{id=101, username='liubei', password='390ba5f6b5f18dd4c63d7cda170a0c74', salt='12345', email='nowcoder101@sina.com', type=0, status=1, activationCode='null', headerUrl='http://images.nowcoder.com/head/100t.png', createTime=Wed Apr 03 12:04:55 CST 2019}


User{id=101, username='liubei', password='390ba5f6b5f18dd4c63d7cda170a0c74', salt='12345', email='nowcoder101@sina.com', type=0, status=1, activationCode='null', headerUrl='http://images.nowcoder.com/head/100t.png', createTime=Wed Apr 03 12:04:55 CST 2019}


User{id=101, username='liubei', password='390ba5f6b5f18dd4c63d7cda170a0c74', salt='12345', email='nowcoder101@sina.com', type=0, status=1, activationCode='null', headerUrl='http://images.nowcoder.com/head/100t.png', createTime=Wed Apr 03 12:04:55 CST 2019}
```

插入数据：

![image-20220607155454719](D:\Typora\File\nowcode_community\image-20220607155454719.png)

更新数据：

![image-20220607155551496](D:\Typora\File\nowcode_community\image-20220607155551496.png)

3，MyBatis的调试方法

一般在xml文件中写的错误容易看出来，但是在其他的地方的错误不容易看出来，因此需要配置一个日志来查询是哪个地方的问题。

```properties
#logger
logging.level.com.nowcoder.community = debug
logging.file.name=community\community.log
```

这个时候我们会发现我们在打印日志的过程中除了打印普通日志以外，还打印了执行的sql语句，如下图所示：

![image-20220614220843810](D:\Typora\File\nowcode_community\image-20220614220843810.png)

### 第六节，开发社区首页

#### 1，开发流程

1次请求的执行过程

<img src="D:\Typora\File\nowcode_community\image-20220607160615291.png" alt="image-20220607160615291" style="zoom: 50%;" />

我们来看一下，这个页面需要哪些字段：



#### 2，分步实现

开发社区首页，显示前10个帖子

##### ①建立数据库

<img src="D:\Typora\File\nowcode_community\image-20220607164557900.png" alt="image-20220607164557900" style="zoom:67%;" />

##### ②开发实体类

在创建表的时候尽量和数据库中的表名相同，这样便于以后的代码编写

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class DiscussPost {

    //数据库的id
    private int id;
    //用户的id
    private int userId;
    //帖子的标题
    private String title;
    //帖子的内容
    private String content;
    //帖子的类型，1表示置顶
    private int type;
    //帖子的状态，0表示正常，1表示精华，2表示拉黑
    private int status;
    //帖子创建的日期
    private Date createTime;
    //帖子评论的数量
    private int commentCount;
    //帖子的分数
    private double score;

}
```

##### ③开发数据访问层

dao层的java代码：（DiscussPostMapper接口）

```java
@Mapper
public interface DiscussPostMapper {

    //下面得两个方法用于首页的显示

    /**
     * 第一个方法是用来做分页查询的
     * @param userId 用户的id，在首页的时候是用不到的，但是在后面的个人主页上面就会有我的帖子里面
     *               就需要使用到这个userId，因此我们在编写sql语句的时候就可以写一个条件判断，
     *               当我们步传入这个数据的时候，这个userId默认就是0，当为0的时候就表示显示全部的数据
     * @param offset 起始页面
     * @param limit 每页显示的条数
     * @return 返回值就是所有的帖子对象组成的列表
     */
    List<DiscussPost> selectDiscussPosts(int userId, int offset, int limit);

    /**
     * 第二个方法，用来计算所有的帖子的数量，用来实现分页的
     * @param userId 用户id，用来查询用户的信息，显示在首页上面的
     *               @Param 的作用是取别名，比如说我们在编写sql的时候这个字段比较长，
     *               这样就可以通过取别名的方式来让这个字段短一点
     *               另外，如果我们使用动态sql，并且该动态sql的参数只有一个，那么这一个参数一定要取别名的
     * @return 返回值就是帖子的条数
     */
    int selectDiscussPostRows(@Param("userId") int userId);

}
```

dao层的sql语句：（discusspost-mapper.xml）

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.nowcoder.community.dao.DiscussPostMapper">


    <sql id="selectFields">
        id,user_id,title,content,type,status,create_time,comment_count,score
    </sql>
    <!--分页查询，显示所有的数据-->
    <!--此时的返回值类型只需要申明泛型即可，而不需要去声明这是一个List集合-->
    <!--List<DiscussPost> selectDiscussPosts(int userId, int offset, int limit);-->
    <select id="selectDiscussPosts" resultType="DiscussPost">
        select <include refid="selectFields" />
        from Discuss_post
        /*2表示的是拉黑的帖子，所以我们不会显示拉黑的帖子*/
        where status != 2
        <!--这里需要有条件判断-->
        <!--
			我们在进行查找的时候可以会传参数，也可能不会传参数，当我们在传参数的时候，就需要将该参数拼接进sql语句中了，
			这个是为了以后的一些功能了，就不需要再进行重新去编写mapper方法和sql语句
		-->

        <if test="userId != 0">
            and user_id = #{userId}
        </if>
        /*表示置顶的要放在前面，最新的放在前面*/
        order by type desc,create_time desc
        limit #{offset},#{limit}
    </select>

    <!--查询所有的数据的数量-->
    <!--int selectDiscussPostRows(@Param("userId") int userId);-->
    <select id="selectDiscussPostRows" resultType="Integer">
        select count(id)
        from Discuss_post
        where status != 2
        <if test="userId != 0">
            and user_id = #{userId}
        </if>
    </select>
</mapper>
```

**count(1)，count(*)，count(某一字段)的区别：**

执行效果上 ：
count(*)包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL
count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL
count(字段)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计。

执行效率上：
列名为主键，count(指定字段)会比count(1)快
列名不为主键，count(1)会比count(指定字段)快
如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）
如果有主键，则 select count（主键）的执行效率是最优的
如果表只有一个字段，则 select count(*）最优。

为了检测我们的mapper或者sql语句是否出现了错误，我们每次在完成了dao层代码的编写了以后最好来做一个测试。（MapperTests类）

```java
@Autowired
private DiscussPostMapper discussPostMapper;


@Test
public void testSelectDiscuss(){
    List<DiscussPost> discussPosts = discussPostMapper.selectDiscussPosts(103, 0, 10);
    for(int i = 0;i < discussPosts.size();i++){
        System.out.println(discussPosts.get(i));
    }

    int i = discussPostMapper.selectDiscussPostRows(0);
    System.out.println(i);
}
```

然后在控制台查看sql是否有问题。

##### ④开发业务逻辑层

​		在这个sql中，我们没有其他的业务逻辑，但是即使是没有具体的业务，我们依然还是需要来使用service来调用dao，最好不要使用controller直接来调用dao。如果跨层调用的话，到后来业务变大的时候就会对整个项目的结构造成破坏。

```java
@Service
public class DiscussPostService {

    @Autowired
    private DiscussPostMapper discussPostMapper;

    /**
     * 分页查询
     * @param userId 用户id
     * @param offset 偏移量
     * @param limit 每页显示的条数
     * @return 返回List集合
     */
    public List<DiscussPost> findDiscussPosts(int userId, int offset, int limit){
        return discussPostMapper.selectDiscussPosts(userId,offset,limit);
    }

    /**
     *  查询总条数
     * @param userId 用户id
     * @return 查询的条数
     */
    public int findDiscussPostRows(int userId){
        return discussPostMapper.selectDiscussPostRows(userId);
    }
}

```

##### ⑤开发视图层

开发分页组件，分页显示所有的帖子

```java
@Controller
public class HomeController {

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private UserService userService;

    @RequestMapping(path = "/index",method = RequestMethod.GET)
    public String getIndexPage(Model model, Page page){

        //方法调用前，SpringMVC会自动实例化Model和Page，并将Page注入Model
        //因此在thymeleaf中可以直接访问Page对象中的数据
        //我们在传入数据的时候，只需要传入这两组数据即可，其他的都可以来进行计算得到
        //计算数据的总行数，因为是首页，所以不需要通过userId来进行查询
        page.setRows(discussPostService.findDiscussPostRows(0));
        //写出当前的访问路径
        page.setPath("/index");

        //查询帖子,查询到的字段有id,user_id,title,content,type,status,create_time,comment_count,score
        //但是我们要的不是user_id，我们要的是用户名，因此我们还需要遍历这个帖子，然后根据这个用户id来查询用户名
        List<DiscussPost> list = discussPostService.findDiscussPosts(0, page.getOffset(), page.getLimit());
        //这个集合里面放的是需要前端页面来进行显示的帖子对象和用户对象的map集合
        List<Map<String,Object>> discussPosts = new ArrayList<>();
        if(list != null){
            for(DiscussPost post : list){
                //这里放的就是帖子对象和用户对象
                Map<String,Object> map = new HashMap<>();
                //获取用户对象
                User user = userService.findUserById(post.getUserId());
                //将每一篇帖子对象和用户对象都放到map中
                map.put("post",post);
                map.put("user",user);
                //把每一篇帖子都放到这个list集合中
                discussPosts.add(map);
            }
        }
        //然后传递给前端
        model.addAttribute("discussPosts",discussPosts);
        //返回的是模板的路径，也就是templates下的html文件，这里这个目录下的文件以/开头，后面照着写就行
        return "/index";
    }
}
```

前端页面的修改：

<img src="D:\Typora\File\nowcode_community\image-20220608154018461.png" alt="image-20220608154018461" style="zoom:80%;" />

![image-20220608154127592](D:\Typora\File\nowcode_community\image-20220608154127592.png)

分页功能的显示：现在是可以使用分页插件来做的，这里我们手写一个分页插件，来看一下分页的底层。

显示的效果：

<img src="D:\Typora\File\nowcode_community\image-20220608160306724.png" alt="image-20220608160306724" style="zoom:80%;" />

Page类：

```java
/**
 * 封装分页相关的信息.
 */
public class Page {

    // 当前页码
    private int current = 1;
    // 显示上限
    private int limit = 10;
    // 数据总数(用于计算总页数)
    private int rows;
    // 查询路径(用于复用分页链接)
    private String path;

    public int getCurrent() {
        return current;
    }

    public void setCurrent(int current) {
        if (current >= 1 && current <= 100) {
            this.current = current;
        }
    }

    public int getLimit() {
        return limit;
    }

    public void setLimit(int limit) {
        if (limit >= 1 && limit <= 100) {
            this.limit = limit;
        }
    }

    public int getRows() {
        return rows;
    }

    public void setRows(int rows) {
        if (rows >= 0) {
            this.rows = rows;
        }
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    /**
     * 获取当前页的起始行
     * @return 获取当前页的起始行
     */
    public int getOffset() {
        // current * limit - limit
        return (current - 1) * limit;
    }

    /**
     * 获取总页数
     * rows表示数据的总数量，limit表示每页显示的数量
     * @return 获取总页数
     */
    public int getTotal() {
        // rows / limit [+1]
        if (rows % limit == 0) {
            return rows / limit;
        } else {
            return rows / limit + 1;
        }
    }

    /**
     * 获取起始页码
     * 这里就是显示获取当前页的前两页，一个显示5页
     * @return 获取起始页码
     */
    public int getFrom() {
        int from = current - 2;
        //如果小于两页，就显示前1页
        return Math.max(from, 1);
    }

    /**
     * 获取结束页码
     * 这里就是显示获取当前页的后两页，一个显示5页
     * @return 获取结束页码
     */
    public int getTo() {
        int to = current + 2;
        int total = getTotal();
        //如果大于了最后的一页，就显示最后的一页
        return Math.min(to, total);
    }
}
```

<img src="D:\Typora\File\nowcode_community\image-20220608160640708.png" alt="image-20220608160640708" style="zoom:67%;" />

controller层对分页的操作：

<img src="D:\Typora\File\nowcode_community\image-20220608161349603.png" alt="image-20220608161349603" style="zoom:67%;" />

前端页面的修改：

<img src="D:\Typora\File\nowcode_community\image-20220608164501649.png" alt="image-20220608164501649" style="zoom:67%;" />

**分页插件的使用步骤：**



### 第七节，项目调试技巧

#### 1，响应状态码的含义

参考网站：https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/

常见的状态码的介绍：

①以2开头的都表示成功了

②以3开头的都表示重定向，我们遇到的最多的就是302(重定向状态码表明请求的资源被暂时的移动到了由该 HTTP 响应的响应头 Location指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新)

<img src="D:\Typora\File\nowcode_community\image-20220603212111536.png" alt="image-20220603212111536" style="zoom: 50%;" />

背景说明：我们在服务器端删除掉一条数据，但是在返回的时候需要返回的是一个页面，这个时候我们就需要去再调用服务器端的查询操作，然后在页面上面返回数据，但是这样使用的话，它的耦合度太高了，如果我们在单独调用查询的操作的时候可能会影响到删除的操作。这个时候我们可以使用重定向了，如下图所示：

<img src="D:\Typora\File\nowcode_community\image-20220603212724378.png" alt="image-20220603212724378" style="zoom: 50%;" />

使用重定向的时候在调用了删除的操作以后，服务器端给客户端返回一个302请求（表示一个建议），这个302请求带着一个地址，建议浏览器可以去访问这个地址，这样的话浏览器就会再次发起一个查询的请求进行数据的查询，这样的话就可以很大程度的降低程序的耦合度，比如我们在进行登录和注册之间就可以使用重定向，redirect:location

④以4开头的都表示客户端的错误，我们最常见的就是404（服务器端无法找到所请求的资源，一般是我们的路径写错了，然后找不到资源，这个时候我们需要去检查我们写的数据的路径）

⑤以5开头的都表示服务器端的错误，我们最常见的就是500（意味着所请求的服务器遇到意外的情况并阻止其执行请求）

#### 2，服务端断点的调试技巧

断点的设置：

<img src="D:\Typora\File\nowcode_community\image-20220603215101965.png" alt="image-20220603215101965" style="zoom: 80%;" />

debug功能键的介绍：

![image-20220603215235163](D:\Typora\File\nowcode_community\image-20220603215235163.png)

1表示进行下一步执行代码，通过该功能键，可以确定代码执行顺序是否有误。

2表示可以进入方法内去查看代码执行情况。

3表示蓝色的执行下一行代码的功能键无法进入API提供的方法中，而红色的执行下一行代码可以进入API提供的方法中。

4表示当代码跳转至方法内后，想要从方法内的代码跳转会原代码执行位置，需通过该功能键。

5、6一般用不上

#### 3，客户端断点的调试技巧

客户端的断点都是对js文件来打的。

<img src="D:\Typora\File\nowcode_community\image-20220603220618163.png" alt="image-20220603220618163" style="zoom: 67%;" />

#### 4，设置日志级别，并将日志输出到不同的终端

```java
//在测试类里面测试日志：
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class LoggerTests {

    private static final Logger logger = LoggerFactory.getLogger(LoggerTests.class);

    @Test
    public void testLogger(){
        System.out.println(logger.getName());

        logger.debug("debug log");
        logger.info("info log");
        logger.warn("warn log");
        logger.error("error log");
    }
}

然后在application.property配置文件中设置打印的级别，只有比这个级别高的日志才会打印：
    打印级别从小到大分别是tarce-->debug-->info-->warn-->error 
#logger
logging.level.com.nowcoder.community = debug
    表示只有比degug级别高的日志才会打印
此时控制台的打印是：
com.nowcoder.community.LoggerTests
2022-06-03 22:21:35.474 DEBUG 6492 --- [      main] com.nowcoder.community.LoggerTests       : debug log
2022-06-03 22:21:35.474  INFO 6492 --- [      main] com.nowcoder.community.LoggerTests       : info log
2022-06-03 22:21:35.474  WARN 6492 --- [      main] com.nowcoder.community.LoggerTests       : warn log
2022-06-03 22:21:35.474 ERROR 6492 --- [      main] com.nowcoder.community.LoggerTests       : error log
```

我们在开发的过程中，日志默认都是打印到控制台上面的，但是我们在实际的开发过程中都是直接部署到服务器上面的，这个时候就需要将日志打印到文件中，具体操作如下：

在appliaction.properties配置文件中写上如下配置

```properties
#logger
logging.level.com.nowcoder.community = debug
logging.file.name=community/community.log
```

程序运行的结果是新建了该文件，里面的内容如下：

<img src="D:\Typora\File\nowcode_community\image-20220604081758216.png" alt="image-20220604081758216" style="zoom: 67%;" />



在实际的开发应用中，我们不能将所有的日志都打印到同一个文件，这个时候就需要一个配置文件来配置将不同级别的日志打印到不同的文件中，并且设置日志存放的天数，日志输入的格式等，具体如下：

```xml
<configuration>
    <!--项目名称-->
    <contextName>community</contextName>
    <!--项目存放的位置-->
    <property name="LOG_PATH" value="D:\loggingFile"/>
    <!--下一级目录，因为我们一般会在一个服务器上面部署多个项目，每个项目的日志都是放在同一个目录下面的-->
    <property name="APPDIR" value="community"/>
    <!--错误级别的日志-->
    <!--  error file  -->
    <appender name="FILE_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--文件的输出路径和文件名-->
        <file>${LOG_PATH}/${APPDIR}/log_error.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--我们可以设置每个文件的大小，当文件达到该大小的时候，我们就新建一个新的文件，这个文件名的后缀会加一-->
            <fileNamePattern>${LOG_PATH}/${APPDIR}/error/log-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <!--最大的文件的大小-->
                <maxFileSize>5MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--文件的最长存活的天数-->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <!--以追加的方式进行存储-->
        <append>true</append>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <!--文件的数据格式-->
            <pattern>%d %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
            <!--编码-->
            <charset>utf-8</charset>
        </encoder>
        <!--输出的文件的级别-->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>error</level>
            <!--表示只有是这个级别的日志才会输出，不是这个级别的日志是不会输出的-->
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <!--这个是warn级别的日志，配置和上面一样-->
    <!--  warn file  -->
    <appender name="FILE_WARN" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APPDIR}/log_warn.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APPDIR}/warn/log-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>5MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <append>true</append>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>warn</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <!--这个是info级别的日志，配置和上面一样-->
    <!--  info file  -->
    <appender name="FILE_INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APPDIR}/log_info.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APPDIR}/info/log-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>5MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <append>true</append>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>info</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <!--  console  -->
    <!--这个表示打印到控制台上面-->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>debug</level>
        </filter>
    </appender>
    <logger name="com.nowcoder.community" level="debug"/>
    <root level="info">
        <appender-ref ref="FILE_ERROR"/>
        <appender-ref ref="FILE_WARN"/>
        <appender-ref ref="FILE_INFO"/>
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>

运行的结果如下：
在控制台上面的输出：
com.nowcoder.community.LoggerTests
2022-06-04 08:39:58,464 DEBUG [main] c.n.c.LoggerTests [LoggerTests.java:24] debug log
2022-06-04 08:39:58,464 INFO [main] c.n.c.LoggerTests [LoggerTests.java:25] info log
2022-06-04 08:39:58,465 WARN [main] c.n.c.LoggerTests [LoggerTests.java:26] warn log
2022-06-04 08:39:58,465 ERROR [main] c.n.c.LoggerTests [LoggerTests.java:27] error log


在文件里面的输出：
```

<img src="D:\Typora\File\nowcode_community\image-20220604084158842.png" alt="image-20220604084158842" style="zoom:67%;" />

### 第八节，版本控制

版本控制的作用：

1. 可以用于用户代码的备份，如果硬盘坏了，也可以找到自己写的代码

2. 我们在进行每一次的提交都是会有记录的，因此我们可以找到不同版本的代码

3. 同一个团队可以共享代码，然后可以相互修改代码


#### 1，认识Git

参考网址：http://git-scm.com/book/zh/v2

#### 2，Git的常用命令

##### ①将代码提交至本地仓库



##### ②将代码上传至远程仓库



#### 3，IDEA集成Git

## 第二章，Spring Boot实践，开发社区登录模块

### 第一节，发送邮件

#### 1，邮箱设置

第一步，需要 开启邮箱的POP3/SMTP服务，我这里使用的是qq邮箱，如下图所示：

<img src="D:\Typora\File\nowcode_community\image-20220604094101529.png" alt="image-20220604094101529" style="zoom:67%;" />

#### 2，Spring Email

第二步，导入依赖：

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
    <version>2.6.3</version>
</dependency>
```

第三步，在java的配置文件里面配置关于邮箱的设置

```xm
#MailProperties
spring.mail.host=smtp.qq.com
spring.mail.port=465
spring.mail.username=2094881532@qq.com
spring.mail.password=*****************
spring.mail.protocol=smtps
spring.mail.properties.mail.smtp.ssl.enable=true
```

第四步，编写java代码：(MailClient类)

```java
@Component
public class MailClient {

    private static final Logger logger = LoggerFactory.getLogger(MailClient.class);

    @Autowired
    private JavaMailSender mailSender;

    //表示发件人，这个是固定不变的
    @Value("${spring.mail.username}")
    private String from;

    /**
     * 表示邮件的发送
     * @param to 表示把邮件发送给谁
     * @param subject 表示主题
     * @param content 表示内容
     */
    public void sendMail(String to, String subject, String content) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message);
            //设置发件人
            helper.setFrom(from);
            //设置收件人
            helper.setTo(to);
            //设置主题
            helper.setSubject(subject);
            //设置内容，true表示支持html
            helper.setText(content, true);
            mailSender.send(helper.getMimeMessage());
        } catch (MessagingException e) {
            logger.error("发送邮件失败:" + e.getMessage());
        }
    }
}
```

然后进行java代码的测试：

```java
@SpringBootTest
//表示以该配置类来启动主程序
@ContextConfiguration(classes = CommunityApplication.class)
public class MailTests {

    @Autowired
    private MailClient mailClient;

    @Test
    public void TestTextMail(){
        mailClient.sendMail("2094881532@qq.com","TEST","Hello World");
    }
}
```

这样就可以在qq邮箱里面收到**Hello World**的邮件了

#### 3，模板引擎

第五步：

创建一个html页面的demo：（在mail中创建一个demo.html页面）

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>邮件示例</title>
</head>
<body>
<p>欢迎你, <span style="color:red;" th:text="${username}"></span>!</p>
</body>
</html>
```

然后进行java代码的测试：使用模板引擎是为了发送一个html页面，其实最后调用的还是 mailClient.sendMail方法

```java
	@Autowired
    private TemplateEngine templateEngine;

    @Test
    public void TestHTMLMail(){
        Context context = new Context();
        context.setVariable("username","GuoDingWei");
        String process = templateEngine.process("/mail/demo", context);
        System.out.println(process);
        mailClient.sendMail("2094881532@qq.com","HTML","Hello World!!!");
    }
```

然后就可以收到**Hello World!!!**的qq邮件了，同时控制台也显示出来process的html页面：

![image-20220615215753721](D:\Typora\File\nowcode_community\image-20220615215753721.png)

### 第二节，开发注册功能

#### 1，访问注册页面

点击顶部区域内的链接，打开注册页面，如下图所示：

<img src="D:\Typora\File\nowcode_community\image-20220604135030782.png" alt="image-20220604135030782" style="zoom:50%;" />

在这里的一个逻辑就是我们首先访问的是index页面，然后点击index页面的注册按钮的时候就会跳转到注册页面了

<img src="D:\Typora\File\nowcode_community\image-20220604135219806.png" alt="image-20220604135219806" style="zoom:80%;" />

我们在这里设置的都是使用thymeleaf，包括js文件都是设置的th开头的，后面都是@{}来表示的，这个是thymeleaf的语法。

<img src="D:\Typora\File\nowcode_community\image-20220604135523575.png" alt="image-20220604135523575" style="zoom:80%;" />

然后这里的/register路径就会找controller中的相同的路径，然后进行controller中的操作。在这里就是跳转到/site/register去。

我们在编写页面的时候，一般会有很多重复的部分，我们不能在每个部分都是这样写的，因此我们可以使用复用。比如我们在index.html页面上面写好改页面，然后在其他页面进行复用：

<img src="D:\Typora\File\nowcode_community\image-20220615222316549.png" alt="image-20220615222316549" style="zoom:67%;" />

<img src="D:\Typora\File\nowcode_community\image-20220615222443470.png" alt="image-20220615222443470" style="zoom:67%;" />

#### 2，提交注册数据

添加依赖

```xml
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
</dependency>
```

添加配置

```properties
#community
#因为我们在注册的时候会发送一封邮件，这封邮件会有一个链接来让我们来激活账号，这个链接的地址就是我们的服务器，因此会有如下的配置
community.path.domain=http://localhost:8080
```

编写一个工具类，方便以后来使用（CommunityUtil类）

```java
public class CommunityUtil {

    // 生成随机字符串
    public static String generateUUID() {
        //这个UUID生成的是cdf39d05-dde1-4726-b53b-c23158f1f897这样的一串数据
        return UUID.randomUUID().toString().replaceAll("-", "");
    }

    // MD5加密，该加密算法是单向加密，即只能加密，不能解密
    // hello -> abc123def456
    // hello + 3e4a8 -> abc123def456abc
    public static String md5(String key) {
        if (StringUtils.isBlank(key)) {
            return null;
        }
        return DigestUtils.md5DigestAsHex(key.getBytes());
    }
}
```

- 通过表单提交数据

- 服务端验证账号是否已存在，邮箱是否已注册

- 服务端发送激活邮件


下一步就是写业务逻辑：（UserService类）

```java
/**
 * 用于发送邮件
 */
@Autowired
private MailClient mailClient;

/**
 * 模板引擎
 */
@Autowired
private TemplateEngine templateEngine;

/**
 * 域名（本地地址）
 */
@Value("${community.path.domain}")
private String domain;

/**
 * 访问路径
 */
@Value("${server.servlet.context-path}")
private String contextPath;
/**
     * 用户注册功能
     * @param user 注册的内容中要包括账号，密码，邮箱等，因此直接从前端传入一个User对象最好
     * @return 返回值其实很多类型都是可以的，不过为了保证当注册失败的时候输出多种不同的信息
     *          （比如用户已存在，邮箱已存在，注册失败等一些错误），最好返回一个Map
     */
public Map<String, Object> register(User user){
    Map<String,Object> map = new HashMap<>();

    //非空判断
    //当下列任意一项出现空值的时候，我们就可以直接结束这个方法了
    if(user == null){
        throw new IllegalArgumentException("参数不能为空!");
    }
    if(StringUtils.isBlank(user.getUsername())){
        map.put("usernameMsg","账号不能为空");
        return map;
    }

    if(StringUtils.isBlank(user.getPassword())){
        map.put("passwordMsg","密码不能为空");
        return map;
    }

    if(StringUtils.isBlank(user.getEmail())){
        map.put("emailMsg","邮箱不能为空");
        return map;
    }

    //验证判断
    //账号验证
    User u = userMapper.selectByName(user.getUsername());
    if(u != null){
        map.put("usernameMsg","该账号已存在!");
        return map;
    }
    //邮箱验证
    u = userMapper.selectByEmail(user.getEmail());
    if(u != null){
        map.put("emailMsg","该邮箱已被注册!");
        return map;
    }

    //程序运行到这里，就说明我们填入的信息是没有任何问题的，这个时候就可以直接注册了
    //使用盐对密码进行加密
    user.setSalt(CommunityUtil.generateUUID().substring(0,5));//取前五位
    user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));
    //注册的时候我们需要注意的是我们在前端传入的数据只有账号，密码和邮箱，而数据库的其他字段是需要我们自己设置的
    user.setType(0);//注册的用户默认都是普通用户
    user.setStatus(0);//此时用户账号还没有激活
    user.setActivationCode(CommunityUtil.generateUUID());
    user.setHeaderUrl(String.format("http://images.nowcoder.com/head/%dt.png",new Random().nextInt(1000)));
    user.setCreateTime(new Date());
    userMapper.insertUser(user);

    //激活邮件
    Context context = new Context();
    context.setVariable("email", user.getEmail());
    // http://localhost:8080/community/activation/101/code
    //我们是没有自己设置id的，但是我们在数据的插入的时候使用的是主键自增，因此这个时候就会自动生成id了
    String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode();
    context.setVariable("url", url);
    String content = templateEngine.process("/mail/activation", context);
    mailClient.sendMail(user.getEmail(), "激活账号", content);

    return map;
}
```

此时我们需要编辑我们的用于发送给用户激活账号的页面（下面分别是activation.html页面和operate-result.html页面）

<img src="D:\Typora\File\nowcode_community\image-20220617104223807.png" alt="image-20220617104223807" style="zoom: 67%;" />

<img src="D:\Typora\File\nowcode_community\image-20220617104602236.png" alt="image-20220617104602236" style="zoom:67%;" />

下一步就是编写视图层（LoginController类）

为了页面显示的好看，我们可以再定义一个页面operate-result.html，在注册成功的时候显示该页面，表示用户注册成功，并且返回到首页上面

```java
@Autowired
private UserService userService;
/**
     * 正式注册的方式
     * @param model 用于给前端传递数据
     * @param user 前端传过来的数据
     * @return 返回到指定的页面
     */
@RequestMapping(path = "/register",method = RequestMethod.POST)
public String register(Model model, User user){
    Map<String, Object> map = userService.register(user);
    //表示注册成功
    if(map == null || map.isEmpty()){
        //当注册成功的时候，我们给前端传递成功的信息，同时告诉其跳转到哪个页面
        model.addAttribute("msg", "注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活!");
        model.addAttribute("target", "/index");
        //这是一个中间的页面，中间会暂存几秒钟，最后会跳转到首页
        return "/site/operate-result";
        //表示注册失败
    } else {
        //注册失败的三种情况，分别是用户名，密码，邮箱的问题
        model.addAttribute("usernameMsg", map.get("usernameMsg"));
        model.addAttribute("passwordMsg", map.get("passwordMsg"));
        model.addAttribute("emailMsg", map.get("emailMsg"));
        //注册失败，返回到注册页面
        return "/site/register";
    }
}
```

前端页面的显示（下面我以用户名为例，密码，邮箱等和用户名是一样的）

![image-20220617105201670](D:\Typora\File\nowcode_community\image-20220617105201670.png)

#### 3，激活注册账号

点击邮件中的链接，访问服务端的激活服务

不同的状态码表示不同的激活状态（CommunityConstant接口）

```java
/**
 * 这个接口的作用是专门来定义常量，
 * 后面的类可以实现这个接口，
 * 然后就可以使用这个接口中的方法
 */
public interface CommunityConstant {

    /**
     * 激活成功
     */
    int ACTIVATION_SUCCESS = 0;

    /**
     * 重复激活
     */
    int ACTIVATION_REPEAT = 1;

    /**
     * 激活失败
     */
    int ACTIVATION_FAILURE = 2;
}
```

业务逻辑层（UserService类）

```java
/**
     * 激活注册码
     * 之所以要传这两个参数，是因为下面这条语句传递的这两个参数
     * String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode();
     * @param userId 用户id
     * @param code 激活码
     * @return 返回值就是CommunityConstant接口中的常量，表示是否已经激活
     */
public int activation(int userId, String code) {
    //通过用户注册的时候的主键自增的id来查询当前注册的用户
    User user = userMapper.selectById(userId);
    //如果这个用户的状态为1，表示已经被激活了，就不用重复激活了
    if (user.getStatus() == 1) {
        return ACTIVATION_REPEAT;
        //如果这个用户的激活码和我们传入的激活码是一样的话，就表示现在可以激活，
        //就将数据库中的状态改为1，表示激活
    } else if (user.getActivationCode().equals(code)) {
        userMapper.updateStatus(userId, 1);
        return ACTIVATION_SUCCESS;
    } else {
        //否则就表示激活失败
        return ACTIVATION_FAILURE;
    }
}
```

视图层（LoginController类）：在这里也是用到了operate-result.html页面的，用来点击实现用户的激活

```java
/**
     * 实现激活激活码的视图层
     * 这里的path路径是不能随便写的，这个要和注册的时候用于激活邮件的路径是一样的，
     * 请求方式使用get请求就可以
     * @param model 传递数据给前端
     * @param userId 注册传递过来的用户id
     * @param code 注册传递过来的激活码
     * @return 根据不同的情况返回到不同的页面
     */
// http://localhost:8080/community/activation/101/code
@RequestMapping(path = "/activation/{userId}/{code}", method = RequestMethod.GET)
public String activation(Model model, @PathVariable("userId") int userId, @PathVariable("code") String code) {
    int result = userService.activation(userId, code);
    //表示成功
    if (result == ACTIVATION_SUCCESS) {
        model.addAttribute("msg", "激活成功,您的账号已经可以正常使用了!");
        model.addAttribute("target", "/login");
        //表示重复
    } else if (result == ACTIVATION_REPEAT) {
        model.addAttribute("msg", "无效操作,该账号已经激活过了!");
        model.addAttribute("target", "/index");
        //表示失败
    } else {
        model.addAttribute("msg", "激活失败,您提供的激活码不正确!");
        model.addAttribute("target", "/index");
    }
    return "/site/operate-result";
}
```

### 第三节，会话管理

#### 1，HTTP的基本性质

HTTP是简单的，可扩展的，无状态的，有会话的

#### 2，Cookie

是服务器发送到浏览器，并且保存在浏览器端的一小块数据，浏览器下次访问服务器的时候，会自动携带该块数据，将其发送给服务器

<img src="D:\Typora\File\nowcode_community\image-20220604170624099.png" alt="image-20220604170624099" style="zoom:67%;" />

```java
    //cookie演示
    @RequestMapping(path = "/cookie/set", method = RequestMethod.GET)
    @ResponseBody
    public String setCookie(HttpServletResponse response) {
        // 创建cookie
        Cookie cookie = new Cookie("code", CommunityUtil.generateUUID());
        // 设置cookie生效的范围
        cookie.setPath("/community/alpha");
        // 设置cookie的生存时间
        cookie.setMaxAge(60 * 10);
        // 发送cookie
        response.addCookie(cookie);
        return "set cookie";
    }

    @RequestMapping(path = "/cookie/get", method = RequestMethod.GET)
    @ResponseBody
    public String getCookie(@CookieValue("code") String code) {
        System.out.println(code);
        return "get cookie";
    }
然后我们可以在浏览器的工具--》网络中进行查看，会看到request或者response中的
    Cookie: code=0ad186ef4d34408a869667ac1a4472c4; Idea-37ad6e9e=59732e51-a1c7-43ba-9196-f7dc5eeb2ae0
这样的数据
```

#### 3，Session

是javaEE的标准，用于在服务器端记录客户端信息数据存放在服务端更加安全，但是也会增加服务端的内存压力

<img src="D:\Typora\File\nowcode_community\image-20220604173005481.png" alt="image-20220604173005481" style="zoom:67%;" />

浏览器第一次向服务器发起请求，服务器端会产生一个session，同时服务器端会产生一个带有sessionid的cookie相应到浏览器，下次浏览器再进行访问服务器的时候就可以判断是那个cookie了。

```java
// session示例
@RequestMapping(path = "/session/set", method = RequestMethod.GET)
@ResponseBody
public String setSession(HttpSession session) {
    session.setAttribute("id", 1);
    session.setAttribute("name", "Test");
    return "set session";
}

@RequestMapping(path = "/session/get", method = RequestMethod.GET)
@ResponseBody
public String getSession(HttpSession session) {
    System.out.println(session.getAttribute("id"));
    System.out.println(session.getAttribute("name"));
    return "get session";
}
```

分布式部署的时候为什么用session会有问题：

<img src="D:\Typora\File\nowcode_community\image-20220604195959127.png" alt="image-20220604195959127" style="zoom:67%;" />

​         如上图所示，我们在项目的部署的时候一般都是使用的nginx的，并且我们也是会有多台服务器的，比如服务器1创建了一个cookie响应给浏览器，但是浏览器下一次的请求被服务器3接收到了，这个时候即使已经创建了这个会话，但是服务器3没有这个cookie中的sessionid，因此这个时候就只能再创建一个cookie给浏览器了。解决这个问题的一个方式就是给一台服务器固定分配给这个浏览器的ip，这样可以保证这个请求一定在这台服务器上面，但是这样做的问题就是服务器的负载均衡就会显得特别差。第二个方式就是将这个session同步到每台服务器，但是这样做耦合度太高了。第三个方式就是单独使用一台服务器来装session，每个服务过来的首先会找这个服务器，但是这样的话如果出现了这台服务器宕机了，最后还是无法访问到的。

​		因此现在基本上都是放在cookie中，如果有比较重要的数据，其实是可以将其加入到数据库中。

#### 4，Cookie、Session和Token的区别



### 第四节，生成验证码

使用Kaptcha：首先是生成数字，然后再生成图片

第一步，导包：

```xml
<!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha -->
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>
```

第二步：编写配置类（KaptchaConfig类），然后注入到Spring容器中：

```java
/**
 * 用于登录的时候实现验证码
 * 我们使用java也可以来实现验证码的功能，
 * 但是我们现在使用的是kaptcha工具
 */
@Configuration
public class KaptchaConfig {
    
    @Bean
    public Producer kaptchaProducer() {

        //用于生成验证码的外观形式
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width", "100");//边框的宽度
        properties.setProperty("kaptcha.image.height", "40");//边框的高度
        properties.setProperty("kaptcha.textproducer.font.size", "32");//字体
        properties.setProperty("kaptcha.textproducer.font.color", "0,0,0");//字的颜色
        properties.setProperty("kaptcha.textproducer.char.string", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ");//字符的范围
        properties.setProperty("kaptcha.textproducer.char.length", "4");//字符的长度
        properties.setProperty("kaptcha.noise.impl", "com.google.code.kaptcha.impl.NoNoise");

        //生成验证码
        DefaultKaptcha kaptcha = new DefaultKaptcha();
        Config config = new Config(properties);
        kaptcha.setConfig(config);
        return kaptcha;
    }
}

//kaptcha就是这样的：com.google.code.kaptcha.impl.DefaultKaptcha@2d98a335
```

第三步：编写java代码（LoginController类）

```java
@Autowired
private Producer kaptchaProducer;

private static final Logger logger = LoggerFactory.getLogger(LoginController.class);

/**
     * 用于验证码的生成
     * @param response 由于验证码存储在客户端不安全，因此我们就存储在服务器端
     * @param session 存储在session中
     */
@RequestMapping(path = "/kaptcha", method = RequestMethod.GET)
public void getKaptcha(HttpServletResponse response, HttpSession session) {
    // 生成验证码
    String text = kaptchaProducer.createText();
    BufferedImage image = kaptchaProducer.createImage(text);

    // 将验证码存入session
    session.setAttribute("kaptcha", text);

    // 将图片输出给浏览器
    response.setContentType("image/png");
    try {
        OutputStream os = response.getOutputStream();
        ImageIO.write(image, "png", os);
    } catch (IOException e) {
        logger.error("响应验证码失败:" + e.getMessage());
    }
}
```

测试：

访问网址：http://localhost:8080/community/kaptcha

我们每次刷新的时候显示的图片是不一样的

![image-20220617145016585](D:\Typora\File\nowcode_community\image-20220617145016585.png)

下一步：我们在前端页面显示动态的验证码更新
![image-20220617151151218](D:\Typora\File\nowcode_community\image-20220617151151218.png)

### 第五节，开发登录，退出功能

#### 1，访问登陆页面

点击顶部区域的链接，打开登陆页面

<img src="D:\Typora\File\nowcode_community\image-20220604215518312.png" alt="image-20220604215518312" style="zoom: 67%;" />

#### 2，登录

验证账号、密码、验证码

- 成功时返回登录凭证，发放给客户端，让客户端记住这个凭证，以后在进行资源访问的时候，服务器端就是根据这个凭证来允许访问资源的
- 失败时，跳转会登录页



目前，我们会把一些比较重要的信息（比如用户的id，用户名，密码等），我们将其存到数据库中，以后在项目进行重构的时候，我们可以将这些信息存储到redis中

创建实体类：（LoginTicket类）

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class LoginTicket {

    //id
    private int id;
    //用户id
    private int userId;
    //登录凭证
    private String ticket;
    //登录状态
    private int status;
    //创建日期
    private Date expired;
}
```


dao层（LoginTicketMapper接口）

```java
@Mapper
public interface LoginTicketMapper {

    /**
     * 往数据库中插入凭证
     * @param loginTicket 凭证对象
     * @return 返回成功插入的条数
     */
    int insertLoginTicket(LoginTicket loginTicket);

    /**
     * 根据凭证来进行查询
     * @param ticket 凭证
     * @return 返回凭证对象
     */
    LoginTicket selectByTicket(String ticket);

    /**
     * 更新状态
     * @param ticket 凭证
     * @param status 状态
     * @return 返回成功更新的条数
     */
    int updateStatus(String ticket, int status);
}
```

xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.nowcoder.community.dao.LoginTicketMapper">

    <insert id="insertLoginTicket" useGeneratedKeys="true" keyProperty = "id">
        insert into login_ticket(user_id,ticket,status,expired)
        values(#{userId},#{ticket},#{status},#{expired})
    </insert>

    <select id="selectByTicket" resultType="LoginTicket">
        select id,user_id,ticket,status,expired from login_ticket where ticket=#{ticket}
    </select>


    <update id="updateStatus">
        update login_ticket set status=#{status} where ticket=#{ticket}
        <if test="ticket!=null" />
    </update>

</mapper>
```

mapper代码的测试：（LoginTicketMapper接口）

```java
@Test
public void testLoginTicket(){
    LoginTicket loginTicket = new LoginTicket();
    loginTicket.setUserId(101);
    loginTicket.setTicket("abc");
    loginTicket.setStatus(0);
    loginTicket.setExpired(new Date(System.currentTimeMillis() + 100 * 60 * 10));
    int i = loginTicketMapper.insertLoginTicket(loginTicket);
    System.out.println(i);
    LoginTicket abc = loginTicketMapper.selectByTicket("abc");
    System.out.println(abc);
    int abc1 = loginTicketMapper.updateStatus("abc", 0);
    System.out.println(abc1);
}
```

cervice层：（UserService类）

```java
/**
     * 用户登录的业务逻辑层
     * @param username 用户名
     * @param password 密码
     * @param expiredSeconds 登录时间
     * @return
     */
public Map<String, Object> login(String username, String password, int expiredSeconds) {
    Map<String, Object> map = new HashMap<>();

    // 空值处理
    if (StringUtils.isBlank(username)) {
        map.put("usernameMsg", "账号不能为空!");
        return map;
    }
    if (StringUtils.isBlank(password)) {
        map.put("passwordMsg", "密码不能为空!");
        return map;
    }

    // 验证账号
    User user = userMapper.selectByName(username);
    if (user == null) {
        map.put("usernameMsg", "该账号不存在!");
        return map;
    }

    // 验证状态
    if (user.getStatus() == 0) {
        map.put("usernameMsg", "该账号未激活!");
        return map;
    }

    // 验证密码
    password = CommunityUtil.md5(password + user.getSalt());
    if (!user.getPassword().equals(password)) {
        map.put("passwordMsg", "密码不正确!");
        return map;
    }

    //程序运行到这里，表示登录成功了，
    //但是我们在前端传入的数据是不够的，因此我们还需要手动设置一些信息
    //这些信息都是一样的
    //下面就是需要将登陆凭证提交给服务器
    // 生成登录凭证
    LoginTicket loginTicket = new LoginTicket();
    loginTicket.setUserId(user.getId());
    //当登录成功的时候就需要设置登录凭证，并且将该凭证放到cookie中（以后会重构来放到redis中）
    loginTicket.setTicket(CommunityUtil.generateUUID());
    loginTicket.setStatus(0);
    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));
    loginTicketMapper.insertLoginTicket(loginTicket);

    map.put("ticket", loginTicket.getTicket());
    System.out.println(loginTicket.getTicket());
    return map;
}
```

controller层：(LoginController类)

```java
@Value("${server.servlet.context-path}")
private String contextPath;
    
/**
     *用户登录功能
     * @param username 用户名
     * @param password 密码
     * @param code 验证码
     * @param rememberme 是否记住我
     * @param model 将数据传递给前端
     * @param session 从session中拿到验证码进行比较（验证码不区分大小写）
     * @param response 将登录凭证放到cookie中
     * @return 跳转到指定的页面
     */

@RequestMapping(path = "/login", method = RequestMethod.POST)
public String login(String username, String password, String code, boolean rememberme,
                    Model model, HttpSession session, HttpServletResponse response) {
    // 检查验证码
    String kaptcha = (String) session.getAttribute("kaptcha");
    //验证验证码是否符合规范，这里的验证码是不分大小写，这个时候就会跳转到登录页面，要求重新登陆
    if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) {
        model.addAttribute("codeMsg", "验证码不正确!");
        return "/site/login";
    }

    // 检查账号,密码,是否有记住我（这两个的超时时间是不一样的）
    int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
    Map<String, Object> map = userService.login(username, password, expiredSeconds);
    //只有登录成功以后，map中才会有凭证
    if (map.containsKey("ticket")) {
        //这里表示的就是将该凭证从map集合中拿出来放到cookie中
        Cookie cookie = new Cookie("ticket", map.get("ticket").toString());
        cookie.setPath(contextPath);
        cookie.setMaxAge(expiredSeconds);
        response.addCookie(cookie);
        return "redirect:/index";
        //表示登录失败
    } else {
        model.addAttribute("usernameMsg", map.get("usernameMsg"));
        model.addAttribute("passwordMsg", map.get("passwordMsg"));
        return "/site/login";
    }
}
```

对应的前端页面:

![image-20220617210858271](D:\Typora\File\nowcode_community\image-20220617210858271.png)

这个是登陆页面（login.html页面）

![image-20220617211755046](D:\Typora\File\nowcode_community\image-20220617211755046.png)

![image-20220617211915295](D:\Typora\File\nowcode_community\image-20220617211915295.png)

#### 3，退出

将登录凭证修改为失效状态

dao层我们在前面已经写过了的，因此在这里我们就不写了。在这里我们需要的sql就是改变登录凭证的状态，0表示有效，1表示失效。

service层：

```java
/**
     * 退出登录的业务逻辑
     * @param ticket 改变凭证所对应的状态，
     *               0表示有效，1表示无效
     */
public void logout(String ticket) {
    loginTicketMapper.updateStatus(ticket, 1);
}
```



controller层：

```java
/**
     * 用户退出登录
     * @param ticket 登录凭证，就是将登录凭证的值置为1就表示失效了
     * @return 跳转到登陆页面
     */
@RequestMapping(path = "/logout", method = RequestMethod.GET)
public String logout(@CookieValue("ticket") String ticket) {
    userService.logout(ticket);
    return "redirect:/login";
}
```

前端页面的显示：

![image-20220617212303532](D:\Typora\File\nowcode_community\image-20220617212303532.png)

### 第六节，显示登录信息

#### 1，拦截器示例

定义拦截器，实现HandlerInterceptor，配置拦截器，为它指定拦截、排除的路径

第一步：配置拦截规则：（AlphaInterceptor类）

```java
/**
 * 配置的拦截规则
 */

@Component
public class AlphaInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class);

    //在controller之前执行
    //这里的handler就相当于一个拦截的路径
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.debug("preHandle : "+ handler.toString());
        return true;
    }

    //在controller之后,并且在模板引擎之前执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.debug("postHandle : "+ handler.toString());
    }

    //在TemplateEngine模板引擎之后执行之后执行
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.debug("afterCompletion : "+ handler.toString());
    }
}
```

第二步：配置拦截路径：（WebMvcConfig类）

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private AlphaInterceptor alphaInterceptor;

    /**
     * 配置拦截路径
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //这里表示按照刚刚配置的拦截规则来进行拦截
        registry.addInterceptor(alphaInterceptor)
                //这里表示除了哪些路径不拦截（即排除哪些路径）
                .excludePathPatterns("**/*.css","**/*.js","**/*.png","**/*.jpg","**/*.jpeg")
                //表示具体拦截的路径
                .addPathPatterns("/register","/login");
    }
}
```

第三步：进行测试：

当我们在进行登录的时候，我们会在控制台看到用于测试拦截规则的打印日志

只有当我们访问到有拦截的路径的时候才会触发调用拦截器中的方法，这样就可以实现拦截的作用了

<img src="D:\Typora\File\nowcode_community\image-20220609145213797.png" alt="image-20220609145213797" style="zoom: 67%;" />

#### 2，拦截器应用

在请求开始时查询登录用户 --> 在本次请求中持有用户数据--> 在模板视图中显示用户数据-->在请求结束时清理数据

<img src="D:\Typora\File\nowcode_community\image-20220609150254675.png" alt="image-20220609150254675" style="zoom: 50%;" />

下面我们来看一下代码实现：

第一步：我们先写一个拦截的请求（LoginTicketInterceptor类）

我们先创建两个工具类

第一个是获取http请求中的cookie（CookieUtil类）

```java
//工具类，获取cookie中的值
public class CookieUtil {

    /**
     * 获取cookie中的值
     * @param request 这里给的不是cookie，我们可以根据request
     *                来获取cookie，然后来取cookie中的值
     * @param name 由于cookie中存储的数据都是k-v键值对，
     *             因此我们需要通过key来取value
     * @return 返回cookie中的值
     */
    public static String getValue(HttpServletRequest request, String name) {
        if (request == null || name == null) {
            throw new IllegalArgumentException("参数为空!");
        }
        //通过request来获取cookie，得到的是一个cookie数组
        Cookie[] cookies = request.getCookies();
        //现在来遍历这个cookie，去找需要的name对应的值
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    return cookie.getValue();
                }
            }
        }
        //找不到的话就返回空
        return null;
    }
}
```

第二个是使用一个ThreadLocal来保存用户对象（HostHolder类）

```java
/**
 * 用来实现多线程下的数据的隔离性的
 * 使用一个ThreadLocal本地线程变量来存储这个用户对象，
 * 可以实现多个用户隔离访问同一个用户对象
 * 我们查看了ThreadLocal的源码，发现它是根据线程来存储数据的，
 * 因此每个线程存储的数据是不一样的，即以线程为key来存取值的
 */
@Component
public class HostHolder {

    //ThreadLocal初始化
    private ThreadLocal<User> users = new ThreadLocal<>();

    //数据需要先设置，然后才能访问，否则就会报错的
    public void setUser(User user) {
        users.set(user);
    }

    public User getUser() {
        return users.get();
    }

    //为了防止内存泄漏，所以需要将这个对象清除
    public void clear() {
        users.remove();
    }
}
```

下面正式来写拦截的规则（LoginTicketInterceptor类）

```java
@Component
public class LoginTicketInterceptor implements HandlerInterceptor {

    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    /**
     * 配置拦截规则，这个方法是在controller之前执行的
     * @param request 请求数据，我们的cookie就是通过request来得到的，
     *                因此这个没有cookie，我们依然可以根据request来得到cookie
     * @param response 响应数据
     * @param handler 拦截的方法，比如注册、登录等一些方法
     * @return 返回布尔类型，只有返回true的时候才放行，否则会被拦截
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从cookie中获取凭证
        String ticket = CookieUtil.getValue(request, "ticket");

        if (ticket != null) {
            // 查询凭证
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            // 检查凭证是否有效
            if (loginTicket != null && loginTicket.getStatus() == 0 && loginTicket.getExpired().after(new Date())) {
                // 根据凭证查询用户
                User user = userService.findUserById(loginTicket.getUserId());
                // 在本次请求中持有用户
                //由于服务器对浏览器是一对多的关系，因此每个用户的信息都要独立保存
                //使用ThreadLocal本地线程变量可以保证多线程的环境下来使用这一份数据
                hostHolder.setUser(user);
            }
        }
        return true;
    }

    /**
     * 由于user对象在controller之后，模板引擎之前调用，因此我们可以实现postHandle方法
     * 在执行了controller之后，我们将user对象放到model中，然后结合模板引擎，返回一个动态页面
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        //从ThreadLocal本地线程变量中获取user对象
        User user = hostHolder.getUser();
        //将这个user对象放到model中
        if (user != null && modelAndView != null) {
            modelAndView.addObject("loginUser", user);
        }
    }

    /**
     * afterCompletion是在模板引擎之后来进行调用的，
     * 我们可以在使用了模板引擎之后就不需要user对象了，
     * 这个时候就可以将hostHolder中的user对象清理掉，
     * 防止内存泄漏
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        hostHolder.clear();
    }
}
```

第二步：我们来配置拦截的路径（WebMvcConfig类）

```java
@Autowired
private LoginTicketInterceptor loginTicketInterceptor;
//登录的拦截
registry.addInterceptor(loginTicketInterceptor)
    .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
}
```

第三步，因为所有的页面都是复用了首页的头部分，因此我们需要在首页的前端来配置我们需要拦截的页面功能

![image-20220618002019609](D:\Typora\File\nowcode_community\image-20220618002019609.png)

下面我们来看一下具体的效果：

<img src="C:\Users\20948\AppData\Roaming\Typora\typora-user-images\image-20220609192542500.png" alt="image-20220609192542500" style="zoom:50%;" />

<img src="C:\Users\20948\AppData\Roaming\Typora\typora-user-images\image-20220609192652044.png" alt="image-20220609192652044" style="zoom:50%;" />

#### 3，拦截器的作用





#### 4，拦截器与过滤器的区别





### 第七节，账号设置

#### 1，上传文件

- 请求：必须是POST请求
- 表单：enctype = "multipart/form-data"
- Spring MVC：通过MultipartFile处理上传文件

#### 2，开发步骤

- 访问账号设置页面
- 上传头像
- 获取头像

第一步：因为图片是上传到本地的，因此不需要去访问数据库，我们只需要修改一下图片访问的路径即可。现在来编写mapper代码（UserMapper类）

```java
/**
     * 更新用户的头像（就是用户来更新头像）
     * @param id 传入的参数是用户的id（条件）
     * @param headerUrl 传入的参数是用户的头像地址
     * @return 返回值是更新头像成功的条数
     */
int updateHeader(int id,String headerUrl);
```

xml文件：（修改头像肯定是头像图片的路径）（user-mapper.xml）

```xml
<!--更新用户头像-->
<!--因为在这里我们返回的是int简单类型，因此，我们也可以不用写返回值类型-->
<!--int updateHeader(int id,String headerUrl);-->
<update id="updateHeader">
    /*前面的header_url是数据库中的字段，而headerUrl是我们传入的参数中（实体类）的字段*/
    update user set header_url = #{headerUrl} where id = #{id}
</update>
```

第二步：编写业务逻辑层（UserService类）

```java
/**
     * 修改用户头像上传的路径
     * 因为我们需要更新用户的头像，所以我们要传一个用户的id，
     * 来判断是哪一个用户，同时还需要更新用户的头像，所以我们需要来传递头像的路径
     * 这里我们需要注意的是这次是我们将头像上传到本地，以后在项目进行重构的时候会将头像
     * 上传到云服务器上面的，而且本地路径是d：。。。，而我们在访问路径是localhost：。。。
     * @param userId 用户的id
     * @param headerUrl 头像更新的路径
     * @return 返回更新成功的条数
     */
public int updateHeader(int userId,String headerUrl){
    return userMapper.updateHeader(userId,headerUrl);
}
```

第三步：编写视图层（UserController类）

编写视图层之前，需要在配置文件里面加入一个配置，就是头像上传的路径，这个是本地的路径，但是在数据库中显示的是web的路径

```properties
# 头像上传的位置（application.properties）
community.path.upload = D:/JAVA/tools/data
```

```java
@Controller
@RequestMapping("/user")
public class UserController {

    private static final Logger logger = LoggerFactory.getLogger(UserController.class);

    @Value("${community.path.upload}")
    private String uploadPath;

    @Value("${community.path.domain}")
    private String domain;

    @Value("${server.servlet.context-path}")
    private String contextPath;

    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    /**
     * 从首页跳转到上传头像的页面（setting.html页面）
     * 因为是获取数据，所以需要使用的是get请求
     * @return 跳转到指定的页面
     */
    @RequestMapping(path = "/setting", method = RequestMethod.GET)
    public String getSettingPage() {
        return "/site/setting";
    }

    /**
     * 用户头像的上传
     * @param headerImage 用于接受页面传过来的文件，
     *                    如果是多个这样的文件，那么我们可以使用一个数组来接收
     * @param model 响应的时候将错误的信息传递到前端
     * @return 跳转到指定的页面
     */
    @RequestMapping(path = "/upload", method = RequestMethod.POST)
    public String uploadHeader(MultipartFile headerImage, Model model) {
        //非空判断，表示此时没有选择图片
        if (headerImage == null) {
            model.addAttribute("error", "您还没有选择图片!");
            return "/site/setting";
        }
        //我们在文件上传的时候可能会出现同名的情况，因此我们需要对用户上传到图片进行重命名
        String fileName = headerImage.getOriginalFilename();
        //截取文件的后缀名，后面需要进行拼接，如果没有后缀的话就表示文件的格式有问题，无法上传
        String suffix = fileName.substring(fileName.lastIndexOf("."));
        if (StringUtils.isBlank(suffix)) {
            model.addAttribute("error", "文件的格式不正确!");
            return "/site/setting";
        }

        // 生成随机文件名+后缀名
        fileName = CommunityUtil.generateUUID() + suffix;
        // 确定文件存放的路径（此时这个文件是空的）
        File dest = new File(uploadPath + "/" + fileName);
        try {
            // 存储文件，我们将我们需要上传的信息写入到这个文件中
            headerImage.transferTo(dest);
        } catch (IOException e) {
            logger.error("上传文件失败: " + e.getMessage());
            throw new RuntimeException("上传文件失败,服务器发生异常!", e);
        }

        // 更新当前用户的头像的路径(web访问路径)
        // http://localhost:8080/community/user/header/xxx.png
        //根据hostHolder获取当前用户
        User user = hostHolder.getUser();
        //拼web访问路径
        String headerUrl = domain + contextPath + "/user/header/" + fileName;
        //修改头像的路径
        userService.updateHeader(user.getId(), headerUrl);
        //重定向到首页的访问路径
        return "redirect:/index";
    }

    /**
     * 获取头像的访问路径
     *      @PathVariable的作用是将前端出入的fileName传递到后端来
     * @param fileName 文件名
     * @param response
     */
    @RequestMapping(path = "/header/{fileName}", method = RequestMethod.GET)
    public void getHeader(@PathVariable("fileName") String fileName, HttpServletResponse response) {
        // 服务器存放路径（带上本地路径的全限定名）
        fileName = uploadPath + "/" + fileName;
        // 文件后缀
        String suffix = fileName.substring(fileName.lastIndexOf("."));
        // 响应图片
        response.setContentType("image/" + suffix);
        try (
                FileInputStream fis = new FileInputStream(fileName);
                OutputStream os = response.getOutputStream();
        ) {
            byte[] buffer = new byte[1024];
            int b = 0;
            while ((b = fis.read(buffer)) != -1) {
                os.write(buffer, 0, b);
            }
        } catch (IOException e) {
            logger.error("读取头像失败: " + e.getMessage());
        }
    }

}
```

前端页面的修改

<img src="D:\Typora\File\nowcode_community\image-20220609204914323.png" alt="image-20220609204914323" style="zoom: 80%;" />

效果显示：

<img src="D:\Typora\File\nowcode_community\image-20220609205003967.png" alt="image-20220609205003967" style="zoom:80%;" />

<img src="D:\Typora\File\nowcode_community\image-20220609205104171.png" alt="image-20220609205104171" style="zoom:80%;" />

<img src="D:\Typora\File\nowcode_community\image-20220609205126304.png" alt="image-20220609205126304" style="zoom:80%;" />

#### 3，修改密码

第一步：编写dao层，修改密码

（UserMapper接口）

```java
/**
     * 修改密码
     * @param id 用户的id
     * @param password 新修改的密码
     * @return 返回执行成功的条数
     */
int updatePassword(int id,String password);
```

（user-mapper.xml文件）

```xml
<!--修改密码-->
<!--int updatePassword(int id,String password);-->
<update id="updatePassword">
    update user set password = #{password} where id = #{id}
</update>
```

第二步：编写service层（UserService类）

```java
/**
 * 修改密码
 * @param userId 用户的id
 * @param password 新修改的密码
 * @return 返回执行成功的条数
 */
public int updatePassword(int userId,String password){
    return userMapper.updatePassword(userId,password);
}
```

第三步：编写controller层（UserController类）

```java
/**
 * 用户更新密码
 * @param oldPassword 原来的密码
 * @param newPassword 新的密码
 * @param model 传递给前端的数据
 * @return 跳转到指定的页面
 */
@RequestMapping(path = "/update",method = RequestMethod.POST)
public String updatePassword(String oldPassword,String newPassword,Model model){
    //从hostHolder中获取用户信息
    User user = hostHolder.getUser();
    //将用户输入的密码通过md5加密来和数据库中的密码是否对应，只有当原密码输入正确的时候，才允许修改密码
    oldPassword = CommunityUtil.md5(oldPassword + user.getSalt());
    if(!user.getPassword().equals(oldPassword)){
        model.addAttribute("errorMsg","密码输入错误");
        return "/site/setting";
    }
    //新密码要求8位数据以上
    if (newPassword.length() < 8){
        model.addAttribute("error2","密码长度不能小于8位!");
        return "/site/setting";
    }
    //对新用户输入的密码需要进行md5加密，然后再存入到数据库中
    newPassword = CommunityUtil.md5(newPassword + user.getSalt());
    userService.updatePassword(user.getId(),newPassword);
    return "redirect:/index";
}
```

前端页面的显示：

![image-20220618132701462](D:\Typora\File\nowcode_community\image-20220618132701462.png)

#### 4，图片上传到本地服务器或者云服务器



#### 5，$与@与#的区别





### 第八节，检查登录状态

首先我们来说一个例子：当我们在没有登录的时候，我们是看不到消息或者头像上传之类的信息的，但是如何客户知道这些操作的路径，如果他们就可以直接使用路径来进行操作，这个就是程序的一个bug。因此我们就需要来检查用户的登录状态，我们可以在需要拦截的方法上面加上一个注解，当我们在访问这个注解对应的方法的时候，需要进行判断，只有登陆过了的才能被允许访问。

#### 1，使用拦截器

在方法前标注自定义注解

拦截所有的请求，只处理带有该注解的方法

#### 2，自定义注解

常用的元注解

- @Target
- @Retention
- @Document
- @Inherited

如何读取注解

- Method.getDeclaredAnnotations()
- Method.getAnnotation(Class<T> annotationClass)



第一步：自定义注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LoginRequired {

}
```

第二步：

在指定的方法上面加上该注解，在拦截的过程中就找对应的方法（有该注解的方法）

<img src="D:\Typora\File\nowcode_community\image-20220609213404555.png" alt="image-20220609213404555" style="zoom: 50%;" />

第三步：配置拦截规则

将controller类上面带有@LoginRequired注解的方法进行拦截

**这里需要注意的是我们在进行拦截的方法都是controller中的方法**

```java
@Component
public class LoginRequiredInterceptor  implements HandlerInterceptor {

    @Autowired
    private HostHolder hostHolder;
    /**
     *
     * @param request 请求
     * @param response 响应
     * @param handler 拦截的目标
     * @return 返回是否拦截，true为放行，false为拦截
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //表示如果拦截的是这个方法的话，那么就可以进行拦截，如果是静态资源的话，那么就不用拦截
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            //拦截方法上面带有@LoginRequired的
            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
            //表示需要登录的请求如果没有登陆的话，就强制跳转到登陆页面上面
            if (loginRequired != null && hostHolder.getUser() == null) {
                response.sendRedirect(request.getContextPath() + "/login");
                return false;
            }
        }
        return true;
    }
}
```

第四步：配置拦截路径

这里需要配置路径，目的是为了去掉静态资源，静态资源是不需要进行拦截的。

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private LoginRequiredInterceptor loginRequiredInterceptor;
    /**
     * 配置拦截路径
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(loginRequiredInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }
}
```

​		显示的效果就是当访问的地址为自定义注解标注过的路径的时候，拦截器就会进行判断，只有状态为登录状态的时候才会放行，否则就会进行拦截，并且按照拦截的规则来执行相应的操作，在这里我们使用的是跳转到登陆页面。



## 第三章，Spring Boot实践， 开发社区核心功能

### 第一节，过滤敏感词

前缀树

- 名称：Trie、字典树、查找树
- 特点：查找效率高，消耗内存大
- 应用：字符串检索、词频统计、字符串排序等

敏感词过滤器

- 定义前缀树
- 根据敏感词，初始化前缀树
- 编写过滤敏感词的方法



过滤敏感词的逻辑

<img src="D:\Typora\File\nowcode_community\image-20220609221734388.png" alt="image-20220609221734388" style="zoom: 50%;" />

敏感词过滤器的代码实现：（SensitiveFilter类）

```java
@Component
public class SensitiveFilter {

    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换符
    private static final String REPLACEMENT = "***";

    // 根节点
    private TrieNode rootNode = new TrieNode();

    @PostConstruct
    public void init() {
        try (
                InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        ) {
            String keyword;
            while ((keyword = reader.readLine()) != null) {
                // 添加到前缀树
                this.addKeyword(keyword);
            }
        } catch (IOException e) {
            logger.error("加载敏感词文件失败: " + e.getMessage());
        }
    }

    // 将一个敏感词添加到前缀树中
    private void addKeyword(String keyword) {
        TrieNode tempNode = rootNode;
        for (int i = 0; i < keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);

            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 指向子节点,进入下一轮循环
            tempNode = subNode;

            // 设置结束标识
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }

    /**
     * 过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1
        TrieNode tempNode = rootNode;
        // 指针2
        int begin = 0;
        // 指针3
        int position = 0;
        // 结果
        StringBuilder sb = new StringBuilder();

        while (position < text.length()) {
            char c = text.charAt(position);

            // 跳过符号
            if (isSymbol(c)) {
                // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间,指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现敏感词,将begin~position字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }

    // 前缀树
    private class TrieNode {

        // 关键词结束标识
        private boolean isKeywordEnd = false;

        // 子节点(key是下级字符,value是下级节点)
        private Map<Character, TrieNode> subNodes = new HashMap<>();

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        // 添加子节点
        public void addSubNode(Character c, TrieNode node) {
            subNodes.put(c, node);
        }

        // 获取子节点
        public TrieNode getSubNode(Character c) {
            return subNodes.get(c);
        }
    }
}
```

测试代码：

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class SensitiveTests {

    @Autowired
    private SensitiveFilter sensitiveFilter;

    @Test
    public void testSensitiveFilter(){
        String text = "这里可以赌博，可以嫖娼，可以吸毒，可以开票，哈哈哈";
        text = sensitiveFilter.filter(text);
        System.out.println(text);

        text = "这里可以赌￥￥￥博，可以嫖&&&娼，可以吸（*&毒，可以开@！*票，哈哈哈";
        text = sensitiveFilter.filter(text);
        System.out.println(text);
    }
}
```

效果：

```
这里可以***，可以***，可以***，可以***，哈哈哈
这里可以***，可以***，可以***，可以***，哈哈哈
```

### 第二节，发布帖子

Ajax(Asynchronous JavaScript and XML)异步的javaScript与XML，不是一门新技术，只是一个新的术语。使用AjAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面，现在使用JSON比使用XML更加普遍。

参考文档：https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX

#### 1，示例

使用jQuery发送AJAX请求

首先引入所需要的包

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <scope>test</scope>
</dependency>
<!-- https://mvnrepository.com/artifact/com.alibaba/fastjson -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.75</version>
</dependency>
```

第一步：先写一个工具类，将服务器返回给客户端的数据封装成一个JSON字符串（CommunityUtil类）

```java
/**
     * 获取json格式的字符串
     * @param code 编码，比如200  404 500等
     * @param msg 错误信息
     * @param map 存放原本数据的map集合
     * @return 返回json格式的字符串
     */
public static String getJSONString(int code, String msg, Map<String, Object> map) {
    JSONObject json = new JSONObject();
    json.put("code", code);
    json.put("msg", msg);
    if (map != null) {
        for (String key : map.keySet()) {
            json.put(key, map.get(key));
        }
    }
    return json.toJSONString();
}

//下面两个方法是方法的重载，在有的时候是不需要传递太多的参数的，我们就可以使用方法的重载
public static String getJSONString(int code, String msg) {
    return getJSONString(code, msg, null);
}

public static String getJSONString(int code) {
    return getJSONString(code, null, null);
}

public static void main(String[] args) {
    Map<String, Object> map = new HashMap<>();
    map.put("name", "zhangsan");
    map.put("age", 25);
    System.out.println(getJSONString(0, "ok", map));
}

测试结果是：{"msg":"ok","code":0,"name":"zhangsan","age":25}
```

第二步：

编写java代码（在AlphaController类中）

```java
//ajax示例
@RequestMapping(path = "/ajax",method = RequestMethod.POST)
@ResponseBody
public String testAjax(String name,int age){
    System.out.println(name);
    System.out.println(age);
    return CommunityUtil.getJSONString(0,"操作成功!");
}
```

编写前端页面（在ajax-demo.html中）

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AJAX</title>
</head>
<body>
<p>
    <input type="button" value="发送" onclick="send();">
</p>

<script src="https://code.jquery.com/jquery-3.3.1.min.js" crossorigin="anonymous"></script>
<script>
    function send() {
        $.post(
            "/community/alpha/ajax",
            {"name":"张三","age":23},
            function(data) {
                console.log(typeof(data));
                console.log(data);

                data = $.parseJSON(data);
                console.log(typeof(data));
                console.log(data.code);
                console.log(data.msg);
            }
        );
    }
</script>
</body>
</html>
```

显示的效果：访问[AJAX](http://localhost:8080/community/html/ajax-demo.html)路径，点击发送，就会看到下列的数据

<img src="D:\Typora\File\nowcode_community\image-20220610102039642.png" alt="image-20220610102039642" style="zoom:80%;" />

#### 2，实践

采用AJAX请求，实现发布帖子的功能

第一步：首先编写dao层（DiscussPostMapper类）

```java
    /**
     * 用于帖子的发布
     * @param discussPost 帖子对象
     * @return 返回发布帖子成功的条数
     */
    int insertDiscussPost(DiscussPost discussPost);
```

discusspost-mapper.xml

```xml
<sql id="insertFields">
    user_id, title, content, type, status, create_time, comment_count, score
</sql>

<!--用于帖子的发布-->
<insert id="insertDiscussPost" parameterType="DiscussPost">
    insert into discuss_post(<include refid="insertFields"></include>)
    values(#{userId},#{title},#{content},#{type},#{status},#{createTime},#{commentCount},#{score})
</insert>
```

第二步：编写业务逻辑层（DiscussPostService类）

```java
/**
     * 用于帖子的发布,里面涉及到的有敏感词的过滤
     * @param post 帖子对象
     * @return 增加成功的数量
     */
public int addDiscussPost(DiscussPost post) {
    if (post == null) {
        throw new IllegalArgumentException("参数不能为空!");
    }

    // 转义HTML标记
    //比如在数据库中显示的是<script>aaa</script>
    //我们在页面的显示中也是显示的这些内容，不会进行专业得到一些奇怪的内容
    post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));
    post.setContent(HtmlUtils.htmlEscape(post.getContent()));
    // 过滤敏感词
    post.setTitle(sensitiveFilter.filter(post.getTitle()));
    post.setContent(sensitiveFilter.filter(post.getContent()));

    //实现数据的插入
    return discussPostMapper.insertDiscussPost(post);
}
```

第三步：编写视图层（一般包括controller和前端页面）

DiscussPostController类：

```java
@Controller
@RequestMapping("/discuss")
public class DiscussPostController {

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private HostHolder hostHolder;

    /**
     * 增加帖子，即发布帖子
     * @param title 在发布帖子里面有两个部分的内容，
     *              一个部分是标题，另一部分是内容
     * @param content
     * @return
     */
    @RequestMapping(path = "/add", method = RequestMethod.POST)
    @ResponseBody
    public String addDiscussPost(String title, String content) {
        //用户的信息放在了ThreadLocal中的
        User user = hostHolder.getUser();
        if (user == null) {
            return CommunityUtil.getJSONString(403, "你还没有登录哦!");
        }

        //在数据库中帖子是有很多的属性的，我们在前端传入的数据只有标题和内容，其他的都没有
        //但是其他的内容都差不多，因此我们可以在后台来进行手动传入参数。
        DiscussPost post = new DiscussPost();
        post.setUserId(user.getId());//作者id
        post.setTitle(title);//帖子标题
        post.setContent(content);//帖子内容
        post.setCreateTime(new Date());//帖子的创建时间
        discussPostService.addDiscussPost(post);//增加帖子

        // 报错的情况,将来统一处理.
        return CommunityUtil.getJSONString(0, "发布成功!");
    }
}
```

js（index.js）

```javascript
function publish() {
   $("#publishModal").modal("hide");

   // 获取标题和内容
   var title = $("#recipient-name").val();
   var content = $("#message-text").val();
   // 发送异步请求(POST)
   $.post(
      CONTEXT_PATH + "/discuss/add",
      {"title":title,"content":content},
      function(data) {
         data = $.parseJSON(data);
         // 在提示框中显示返回消息
         $("#hintBody").text(data.msg);
         // 显示提示框
         $("#hintModal").modal("show");
         // 2秒后,自动隐藏提示框
         setTimeout(function(){
            $("#hintModal").modal("hide");
            // 刷新页面
            if(data.code == 0) {
               window.location.reload();
            }
         }, 2000);
      }
   );
}
```

前端页面

这里我们没有使用name来获取前端的数据，我们使用的是id来通过js来获取前端传来的title和content数据

<img src="D:\Typora\File\nowcode_community\image-20220610110534977.png" alt="image-20220610110534977" style="zoom: 80%;" />

显示效果：

<img src="D:\Typora\File\nowcode_community\image-20220610110645032.png" alt="image-20220610110645032" style="zoom: 33%;" />

![image-20220610110720413](D:\Typora\File\nowcode_community\image-20220610110720413.png)

### 第三节，帖子详情

- DiscussPostMapper 
- DiscussPostService 
- DiscussPostController
-  index.html 
- - 在帖子标题上增加访问详情页面的链接
-   discuss-detail.html 
- - 处理静态资源的访问路径 
  - 复用index.html的header区域
  - 显示标题、作者、发布时间、帖子正文等内容

**点击帖子，可以跳转到帖子的详情页面上面**

第一步：编写dao层：既然要查询帖子的详情，肯定是是需要根据帖子的id来查询帖子的

Java代码（DiscussPostMapper类）

```java
/**
     * 查询帖子的详细信息
     * @param id 帖子的id
     * @return 返回帖子对象
     */
DiscussPost selectDiscussPostById(int id);
```

Mapper.xml文件：（discusspost-mapper.xml）

```xml
<sql id="selectFields">
id,user_id,title,content,type,status,create_time,comment_count,score
</sql>
<!--查询帖子的详细信息-->
<!--DiscussPost selectDiscussPostById(int id);-->
<select id="selectDiscussPostById" resultType="DiscussPost">
    select <include refid="selectFields"></include>
    from discuss_post
    where id = #{id}
</select>
```

第二步：编写service层（DiscussPostService类）

```java
/**
     * 查询帖子详情
     * @param id 帖子id
     * @return 返回帖子对象
     */
public DiscussPost findDiscussPostById(int id) {
    return discussPostMapper.selectDiscussPostById(id);
}
```

第三步：编写controller层

java代码：

```java
@Autowired
private DiscussPostService discussPostService;

@Autowired
private UserService userService;
/**
     * 查询帖子的详情页面
     *      path = "/detail/{discussPostId}"中的帖子id会在前端
     *      点击标题进行跳转的时候得到这个帖子的id，从而来查询帖子的详情信息
     *      @PathVariable("discussPostId")就是为了获得前端传递过来的参数
     * 因为是向数据库查询信息，因此是get请求
     * @param discussPostId 帖子的id
     * @param model 传递给前端的模板
     * @return 跳转到帖子的详情页面
     */
@RequestMapping(path = "/detail/{discussPostId}", method = RequestMethod.GET)
public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Model model) {
    // 根据点击帖子的标题得到的帖子的id来查询帖子对象
    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
    model.addAttribute("post", post);
    // 注意，这里的作者信息就不是从ThreadLocal中拿到的数据了，这不一定是登录的用户的帖子
    //而是通过帖子对象来查询用户的id，从而根据这个用户的id来查询用户对象
    User user = userService.findUserById(post.getUserId());
    model.addAttribute("user", user);

    return "/site/discuss-detail";
}
```

前端页面：

<img src="D:\Typora\File\nowcode_community\image-20220610131610415.png" alt="image-20220610131610415" style="zoom:80%;" />

<img src="D:\Typora\File\nowcode_community\image-20220610132021189.png" alt="image-20220610132021189" style="zoom:80%;" />

### 第四节，事务管理

事务的概念：事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行

事务的特性（ACID）：

- 原子性：事务是应用中不可再分的最小执行体
- 一致性：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态
- 隔离性：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的
- 持久性：事务一旦提交，对数据所作的任何改变都要记录到永久存储器中

事务的隔离性：

- 常见的并发异常
  - 第一类丢失更新：某一事务的回滚，导致另外一个事务已更新的数据丢失了
  - 第二类丢失更新：某一事务的提交，导致另外一个事务已更新的数据丢失了
  - 脏读：某一时刻，读取了另外一个事务未提交的数据
  - 不可重复读：某一个事务，对同一个数据前后读取的结果不一致
  - 幻读：某一个事务，对同一个表前后查询到的行数不一致
- 常见的隔离级别
  - 读取未提交的数据
  - 读取已提交的数据
  - 可重复读
  - 串行化

![image-20220619082916926](D:\Typora\File\nowcode_community\image-20220619082916926.png)

数据库实现事务的机制：

![image-20220619083101557](D:\Typora\File\nowcode_community\image-20220619083101557.png)

Spring事务管理：

- 声明式事务
  - 通过XML配置，声明某方法的事务特征
  - 通过注解，声明某方法的事务特征
- 编程式事务
  - 通过TransactionTemplate管理事务，并通过它执行数据库操作

#### 1，演示事务的使用

service业务层：（AlphaService类）

```java
@Autowired
private UserMapper userMapper;

@Autowired
private DiscussPostMapper discussPostMapper;

@Autowired
private TransactionTemplate transactionTemplate;


// REQUIRED: 支持当前事务(外部事务),如果不存在则创建新事务.
// REQUIRES_NEW: 创建一个新事务,并且暂停当前事务(外部事务).
// NESTED: 如果当前存在事务(外部事务),则嵌套在该事务中执行(独立的提交和回滚),否则就会REQUIRED一样.
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public Object save1() {
    // 新增用户
    User user = new User();
    user.setUsername("alpha");
    user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
    user.setPassword(CommunityUtil.md5("123" + user.getSalt()));
    user.setEmail("alpha@qq.com");
    user.setHeaderUrl("http://image.nowcoder.com/head/99t.png");
    user.setCreateTime(new Date());
    userMapper.insertUser(user);

    // 新增帖子
    DiscussPost post = new DiscussPost();
    post.setUserId(user.getId());
    post.setTitle("Hello");
    post.setContent("新人报道!");
    post.setCreateTime(new Date());
    discussPostMapper.insertDiscussPost(post);

    Integer.valueOf("abc");

    return "ok";
}

public Object save2() {
    transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
    transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

    return transactionTemplate.execute(new TransactionCallback<Object>() {

        @Override
        public Object doInTransaction(TransactionStatus status) {
            // 新增用户
            User user = new User();
            user.setUsername("beta");
            user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
            user.setPassword(CommunityUtil.md5("123" + user.getSalt()));
            user.setEmail("beta@qq.com");
            user.setHeaderUrl("http://image.nowcoder.com/head/999t.png");
            user.setCreateTime(new Date());
            userMapper.insertUser(user);

            // 新增帖子
            DiscussPost post = new DiscussPost();
            post.setUserId(user.getId());
            post.setTitle("你好");
            post.setContent("我是新人!");
            post.setCreateTime(new Date());
            discussPostMapper.insertDiscussPost(post);
            Integer.valueOf("abc");
            return "ok";
        }
    });
}
```

测试类：

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class TransactionTests {

    @Autowired
    private AlphaService alphaService;

    @Test
    public void testSave1() {
        Object obj = alphaService.save1();
        System.out.println(obj);
    }

    @Test
    public void testSave2() {
        Object obj = alphaService.save2();
        System.out.println(obj);
    }
}
```

#### 2，声明式事务和编程式事务的区别



### 第五节，显示评论

- 数据层 
  - 根据实体查询一页评论数据。
  - 根据实体查询评论的数量。
- 业务层
  - 处理查询评论的业务。 处理查询评论数量的业务。
- 表现层 
  - 显示帖子详情数据时， 同时显示该帖子所有的评论数据

第一步：创建帖子详情页的实体类：（Comment类）

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Comment {

    private int id;
    //用户id
    private int userId;
    //评论实体目标的类型，其中1代表帖子，2代表评论，3代表用户，4代表题目等等等
    private int entityType;
    //评论的实体id，就是帖子的id，是对哪个帖子进行评论
    private int entityId;
    //评论目标的id，就是说是对第一条评论进行评论，还是对具体的某一条的评论进行评论
    private int targetId;
    //评论的内容
    private String content;
    //评论的状态
    private int status;
    //评论的创建时间
    private Date createTime;
}
```

第二步：编写dao层

java代码：（CommentMapper接口）

```java
@Mapper
public interface CommentMapper {

    /**
     * 根据实体类来查询评论，是查询帖子的评论还是评论的评论，
     * 就使用这个实体类型来进行区别，同时还要实现分页的功能
     * @param entityType 实体类型
     * @param entityId 实体类id
     * @param offset 偏移量，用于分页
     * @param limit 每页显示的数量
     * @return 返回查询的评论对象组成的集合
     */
    List<Comment> selectCommentsByEntity(int entityType, int entityId, int offset, int limit);

    /**
     * 根据实体类来查询评论的数量，用于后序的分页的功能
     * @param entityType 实体类型
     * @param entityId 实体类id
     * @return 返回查询的评论的数量
     */
    int selectCountByEntity(int entityType, int entityId);

}
```

Mapper.xml文件：（comment-mapper.xml）

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.nowcoder.community.dao.CommentMapper">

    <sql id="selectFields">
        id, user_id, entity_type, entity_id, target_id, content, status, create_time
    </sql>

    <!--根据实体类来查询评论-->
    <!--List<Comment> selectCommentsByEntity(int entityType, int entityId, int offset, int limit);-->
    <select id="selectCommentsByEntity" resultType="Comment">
        select <include refid="selectFields"></include>
        from comment
        where status = 0
        and entity_type = #{entityType}
        and entity_id = #{entityId}
        order by create_time asc
        limit #{offset}, #{limit}
    </select>

    <!--根据实体类来查询评论的数量-->
    <!--int selectCountByEntity(int entityType, int entityId);-->
    <select id="selectCountByEntity" resultType="int">
        select count(id)
        from comment
        where status = 0
          and entity_type = #{entityType}
          and entity_id = #{entityId}
    </select>

</mapper>
```

第三步：编写service层：（CommentService类）

```java
@Service
public class CommentService {

    @Autowired
    private CommentMapper commentMapper;

    /**
     * 根据实体类型查询评论
     * @param entityType 实体类型
     * @param entityId 实体id
     * @param offset 起始值
     * @param limit 每页显示的条数
     * @return 返回评论对象组成的集合
     */
    public List<Comment> findCommentsByEntity(int entityType, int entityId, int offset, int limit) {
        return commentMapper.selectCommentsByEntity(entityType, entityId, offset, limit);
    }

    /**
     * 根据实体类查询评论数，用于分页
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return 返回查询到的条数
     */
    public int findCommentCount(int entityType, int entityId) {
        return commentMapper.selectCountByEntity(entityType, entityId);
    }

}
```

第四步：编写controller层：（DiscussPostController类）

```java
@RequestMapping(path = "/detail/{discussPostId}", method = RequestMethod.GET)
//discussPostId这个数据是从前端传过来的
public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Model model, Page page) {
    // 帖子（通过帖子的id来查询帖子信息）
    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
    model.addAttribute("post", post);
    // 作者（通过作者的id来查询作者信息）
    User user = userService.findUserById(post.getUserId());
    model.addAttribute("user", user);

    // 评论分页信息
    page.setLimit(5);
    page.setPath("/discuss/detail/" + discussPostId);
    page.setRows(post.getCommentCount());

    // 评论: 给帖子的评论
    // 回复: 给评论的评论
    // 评论列表
    List<Comment> commentList = commentService.findCommentsByEntity(
        ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());
    // 评论VO列表
    List<Map<String, Object>> commentVoList = new ArrayList<>();
    if (commentList != null) {
        for (Comment comment : commentList) {
            // 评论VO
            Map<String, Object> commentVo = new HashMap<>();
            // 评论
            commentVo.put("comment", comment);
            // 作者
            commentVo.put("user", userService.findUserById(comment.getUserId()));

            // 回复列表
            List<Comment> replyList = commentService.findCommentsByEntity(
                ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);
            // 回复VO列表
            List<Map<String, Object>> replyVoList = new ArrayList<>();
            if (replyList != null) {
                for (Comment reply : replyList) {
                    Map<String, Object> replyVo = new HashMap<>();
                    // 回复
                    replyVo.put("reply", reply);
                    // 作者
                    replyVo.put("user", userService.findUserById(reply.getUserId()));
                    // 回复目标
                    User target = reply.getTargetId() == 0 ? null : userService.findUserById(reply.getTargetId());
                    replyVo.put("target", target);

                    replyVoList.add(replyVo);
                }
            }
            commentVo.put("replys", replyVoList);

            // 回复数量
            int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());
            commentVo.put("replyCount", replyCount);

            commentVoList.add(commentVo);
        }
    }

    model.addAttribute("comments", commentVoList);

    return "/site/discuss-detail";
}
```

前端页面的修改：（index.html）

<img src="D:\Typora\File\nowcode_community\image-20220610195744867.png" alt="image-20220610195744867"  />

详情页面（discuss-detail.html）

<img src="D:\Typora\File\nowcode_community\image-20220610200947234.png" alt="image-20220610200947234" style="zoom:80%;" />

![image-20220619112620239](D:\Typora\File\nowcode_community\image-20220619112620239.png)

### 第六节，添加评论

- 数据层
  - 增加评论数据。
  - 修改帖子的评论数量。
- 业务层 
  - 处理添加评论的业务： 先增加评论、再更新帖子的评论数量。 
- 表现层 
  -  处理添加评论数据的请求。
  - 设置添加评论的表单。

**这里我们需要注意的是在添加评论的时候，帖子的评论数量也是需要同时改变的，因此在这个时候是涉及到事务的操作的。**

第一步：编写dao层

添加评论的部分：

java代码：（CommentMapper接口）

```java
/**
     * 添加评论
     * @param comment 评论对象
     * @return 返回添加成功的条数
     */
int insertComment(Comment comment);
```

Mapper.xml文件（comment-mapper.xml）

```xml
<sql id="insertFields">
user_id, entity_type, entity_id, target_id, content, status, create_time
</sql>
<!--添加评论-->
<!--int insertComment(Comment comment);-->
<insert id="insertComment" parameterType="Comment">
    insert into comment(<include refid="insertFields"></include>)
    values(#{userId},#{entityType},#{entityId},#{targetId},#{content},#{status},#{createTime})
</insert>
```

修改评论数的部分：

java代码：（DiscussPostMapper接口）

```java
/**
     * 更新帖子的评论数量
     * @param id 帖子的id
     * @param commentCount 这个帖子的评论数量
     * @return 返回修改成功的条数
     */
int updateCommentCount(int id, int commentCount);
```

Mapper.xml文件（discusspost-mapper.xml）

```xml
<!--更新帖子的数量-->
<!--int updateCommentCount(int id, int commentCount);-->
<update id="updateCommentCount">
    update discuss_post set comment_count = #{commentCount} where id = #{id}
</update>
```

第二步：编写service层

添加评论部分（CommentService类）

```java
@Autowired
private SensitiveFilter sensitiveFilter;

@Autowired
private DiscussPostService discussPostService;

/**
 * 添加评论
 * @param comment
 * @return
 */
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public int addComment(Comment comment) {
    if (comment == null) {
        throw new IllegalArgumentException("参数不能为空!");
    }

    // 添加评论
    comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));
    comment.setContent(sensitiveFilter.filter(comment.getContent()));
    int rows = commentMapper.insertComment(comment);

    // 更新帖子评论数量
    if (comment.getEntityType() == ENTITY_TYPE_POST) {
        int count = commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());
        discussPostService.updateCommentCount(comment.getEntityId(), count);
    }
    return rows;
}
```

更新帖子评论数量部分：（DiscussPostService类）

```java
/**
     * 更新帖子的评论数量
     * @param id 帖子的id
     * @param commentCount 该帖子的评论的数量
     * @return 返回成功的条数
     */
public int updateCommentCount(int id, int commentCount) {
    return discussPostMapper.updateCommentCount(id, commentCount);
}
```

controller层：（CommentController类）

```java
@Controller
@RequestMapping("/comment")
public class CommentController {

    @Autowired
    private CommentService commentService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(path = "/add/{discussPostId}", method = RequestMethod.POST)
    public String addComment(@PathVariable("discussPostId") int discussPostId, Comment comment) {
        comment.setUserId(hostHolder.getUser().getId());
        comment.setStatus(0);
        comment.setCreateTime(new Date());
        commentService.addComment(comment);
        return "redirect:/discuss/detail/" + discussPostId;
    }
}
```

前端页面：这里需要分为三个部分

第一部分：是帖子详情最下面的那个部分

第二部分：是回复某个帖子的部分

第三部分：是回复某个具体人的部分

<img src="D:\Typora\File\nowcode_community\image-20220610210534238.png" alt="image-20220610210534238" style="zoom: 67%;" />

对应的前端页面分别是：（discuss-detail.html）

<img src="C:\Users\20948\AppData\Roaming\Typora\typora-user-images\image-20220610211051614.png" alt="image-20220610211051614" style="zoom:80%;" />

<img src="D:\Typora\File\nowcode_community\image-20220610211429007.png" alt="image-20220610211429007" style="zoom:80%;" />

<img src="D:\Typora\File\nowcode_community\image-20220610211724250.png" alt="image-20220610211724250" style="zoom:80%;" />

**普通return、重定向与转发的区别**：



### 第七节，私信列表

- 私信列表 
  - 查询当前用户的会话列表， 每个会话只显示一条最新的私信。即针对每一条帖子都显示最新的一条私信
  - 支持分页显示。
- 私信详情 
  - 查询某个会话所包含的私信。 
  - 支持分页显示。



第一步：编写实体类（Message类）

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Message {

    private int id;
    //谁发的私信
    private int fromId;
    //谁收的私信
    private int toId;
    //发的私信与收的私信的关系id
    //如果发私信的fromId=111，收私信的toId=222，那么conversationId=111_222
    //我们总是将fromId放在前面，toId放在后面，形式如上所示
    private String conversationId;
    //私信的内容
    private String content;
    //私信的状态，是正常还是拉黑
    private int status;
    //发送私信的时间
    private Date createTime;
}
```

第二步：编写dao层（MessageMapper接口）

```java
@Mapper
public interface MessageMapper {

    /**
     * 查询当前用户的会话列表,针对每个会话只返回一条最新的私信
     * @param userId 用户id
     * @param offset 起始位置
     * @param limit 每页显示的条数
     * @return 返回私信列表组成的集合
     */
    List<Message> selectConversations(int userId, int offset, int limit);

    /**
     * 查询当前用户的会话数量
     * @param userId 用户id
     * @return 返回当前用户的会话数量，为了分页处理
     */
    int selectConversationCount(int userId);

    /**
     * 查询某个会话所包含的私信列表
     * @param conversationId 会话id
     * @param offset 起始位置
     * @param limit 每页显示的数量
     * @return 返回该会话中的私信的数量
     */
    List<Message> selectLetters(String conversationId, int offset, int limit);

    /**
     * 查询某个会话所包含的私信数量
     * @param conversationId 会话id
     * @return 返回当前会话的私信的数量，为了分页处理
     */
    int selectLetterCount(String conversationId);
}
```

Mapper.xml文件（message-mapper.xml）

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.nowcoder.community.dao.MessageMapper">

    <sql id="selectFields">
        id, from_id, to_id, conversation_id, content, status, create_time
    </sql>

    <!--查询当前用户的会话列表,针对每个会话只返回一条最新的私信-->
    <!--List<Message> selectConversations(int userId, int offset, int limit);-->
    <!--我们在查询最新的数据的时候，既可以使用id为最大，也可以使用发布时间最大的情况，在这里我们使用的是id最大的情况-->
    <select id="selectConversations" resultType="Message">
        select <include refid="selectFields"></include>
        from message
        where id in (
        select max(id) from message
        where status != 2
        and from_id != 1
        and (from_id = #{userId} or to_id = #{userId})
        group by conversation_id
        )
        order by id desc
        limit #{offset}, #{limit}
    </select>

    <!--查询当前用户的会话数量-->
    <!--int selectConversationCount(int userId);-->
    <select id="selectConversationCount" resultType="int">
        select count(m.maxid) from (
                                       select max(id) as maxid from message
                                       where status != 2
            and from_id != 1
            and (from_id = #{userId} or to_id = #{userId})
                                       group by conversation_id
                                   ) as m
    </select>

    <!--查询某个会话所包含的私信列表-->
    <!--List<Message> selectLetters(String conversationId, int offset, int limit);-->
    <select id="selectLetters" resultType="Message">
        select <include refid="selectFields"></include>
        from message
        where status != 2
        and from_id != 1
        and conversation_id = #{conversationId}
        order by id desc
        limit #{offset}, #{limit}
    </select>

    <!--查询某个会话所包含的私信数量-->
    <!--int selectLetterCount(String conversationId);-->
    <select id="selectLetterCount" resultType="int">
        select count(id)
        from message
        where status != 2
        and from_id != 1
        and conversation_id = #{conversationId}
    </select>
</mapper>
```

对编写的mapper进行测试：（MapperTests类）

```java
    @Test
    public void testSelectLetters() {
        List<Message> list = messageMapper.selectConversations(111, 0, 20);
        for (Message message : list) {
            System.out.println(message);
        }

        int count = messageMapper.selectConversationCount(111);
        System.out.println(count);

        list = messageMapper.selectLetters("111_112", 0, 10);
        for (Message message : list) {
            System.out.println(message);
        }

        count = messageMapper.selectLetterCount("111_112");
        System.out.println(count);
    }
}
```

第三步：编写service层（MessageService类）

```java
@Service
public class MessageService {

    @Autowired
    private MessageMapper messageMapper;

    public List<Message> findConversations(int userId, int offset, int limit) {
        return messageMapper.selectConversations(userId, offset, limit);
    }

    public int findConversationCount(int userId) {
        return messageMapper.selectConversationCount(userId);
    }

    public List<Message> findLetters(String conversationId, int offset, int limit) {
        return messageMapper.selectLetters(conversationId, offset, limit);
    }

    public int findLetterCount(String conversationId) {
        return messageMapper.selectLetterCount(conversationId);
    }
}
```

第四步：编写controller（MessageController类）

```java
@Controller
public class MessageController {

    @Autowired
    private MessageService messageService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private UserService userService;


    /**
     * 查询私信列表
     * @param model model
     * @param page 分页
     * @return 跳转到指定的路径
     */
    @RequestMapping(path = "/letter/list", method = RequestMethod.GET)
    public String getLetterList(Model model, Page page) {
        //获取用户对象
        User user = hostHolder.getUser();
        // 分页信息
        page.setLimit(5);
        page.setPath("/letter/list");
        page.setRows(messageService.findConversationCount(user.getId()));

        // 获取会话列表
        List<Message> conversationList = messageService.findConversations(
                user.getId(), page.getOffset(), page.getLimit());
        List<Map<String, Object>> conversations = new ArrayList<>();
        if (conversationList != null) {
            for (Message message : conversationList) {
                Map<String, Object> map = new HashMap<>();
                //会话
                map.put("conversation", message);
                //私信
                map.put("letterCount", messageService.findLetterCount(message.getConversationId()));
                //未读消息数量
                map.put("unreadCount", messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));
                //查询目标用户
                int targetId = user.getId() == message.getFromId() ? message.getToId() : message.getFromId();
                map.put("target", userService.findUserById(targetId));

                conversations.add(map);
            }
        }

        model.addAttribute("conversations", conversations);

        //查询总的未读数量，就是最上面的未读的消息数量
        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
        model.addAttribute("letterUnreadCount", letterUnreadCount);

        return "/site/letter";
    }
}
```

前端页面：

![image-20220611105235424](D:\Typora\File\nowcode_community\image-20220611105235424.png)

letter.html页面：

![image-20220611110310059](D:\Typora\File\nowcode_community\image-20220611110310059.png)

![image-20220611111118657](D:\Typora\File\nowcode_community\image-20220611111118657.png)

dao层和service层的方法已经完成了，因此这个只需要写controller层

获取私信详情页的controller（MessageController类）

```java
/**
     * 获取私信的详情
     * @param conversationId 会话的id
     * @param page 分页
     * @param model model
     * @return 跳转到指定的页面
     */
@RequestMapping(path = "/letter/detail/{conversationId}", method = RequestMethod.GET)
public String getLetterDetail(@PathVariable("conversationId") String conversationId, Page page, Model model) {
    // 分页信息
    page.setLimit(5);
    page.setPath("/letter/detail/" + conversationId);
    page.setRows(messageService.findLetterCount(conversationId));

    // 获取私信列表
    List<Message> letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());
    List<Map<String, Object>> letters = new ArrayList<>();
    if (letterList != null) {
        for (Message message : letterList) {
            Map<String, Object> map = new HashMap<>();
            //获取私信
            map.put("letter", message);
            //获取谁给我发的私信，就是发私信的人
            map.put("fromUser", userService.findUserById(message.getFromId()));
            letters.add(map);
        }
    }
    model.addAttribute("letters", letters);

    // 查询私信目标
    model.addAttribute("target", getLetterTarget(conversationId));
    return "/site/letter-detail";
}

/**
     * 获取是谁发送的私信
     * @param conversationId 会话的id
     * @return 返回用户对象
     */
private User getLetterTarget(String conversationId) {
    String[] ids = conversationId.split("_");
    int id0 = Integer.parseInt(ids[0]);
    int id1 = Integer.parseInt(ids[1]);

    if (hostHolder.getUser().getId() == id0) {
        return userService.findUserById(id1);
    } else {
        return userService.findUserById(id0);
    }
}
```

letter-detail.html文件

![image-20220611111559560](D:\Typora\File\nowcode_community\image-20220611111559560.png)

![image-20220611111921849](D:\Typora\File\nowcode_community\image-20220611111921849.png)

<img src="D:\Typora\File\nowcode_community\image-20220611112258976.png" alt="image-20220611112258976" style="zoom: 80%;" />

显示的效果：

私信列表：

<img src="D:\Typora\File\nowcode_community\image-20220611112436919.png" alt="image-20220611112436919" style="zoom:67%;" />

详情列表：

<img src="D:\Typora\File\nowcode_community\image-20220611112527779.png" alt="image-20220611112527779" style="zoom:80%;" />

其中返回的功能实现是通过一个函数来进行实现的，在返回的位置定义一个方法，然后在下面的js进行实现

```html
<button type="button" class="btn btn-secondary btn-sm" onclick="back();">返回</button>
```

```javascript
<script>
   function back() {
      location.href = CONTEXT_PATH + "/letter/list";
   }
</script>
```

### 第八节，发送私信

- 发送私信 
  - 采用异步的方式发送私信。 
  - 发送成功后刷新私信列表。 
-  设置已读 
  - 访问私信详情时， 将显示的私信设置为已读状态。

第一步：dao层（MessageMapper类）

```java
/**
     * 新增消息，即发布消息
     * @param message 消息对象
     * @return 返回新增消息的数量
     */
int insertMessage(Message message);

/**
     * 修改消息的状态，是已读还是未读
     * @param ids 消息（私信）的id
     * @param status 消息（私信）的状态
     * @return 返回修改成功的条数
     */
int updateStatus(List<Integer> ids, int status);

/**
     * 查询未读私信的数量
     * @param userId 用户id
     * @param conversationId 会话id
     * @return 返回查询未读私信的数量
     */
int selectLetterUnreadCount(int userId, String conversationId);
```

Mapper.xml文件（message-mapper.xml文件）

```xml
<sql id="insertFields">
    from_id, to_id, conversation_id, content, status, create_time
</sql>

<!--新增消息，即发布消息-->
<!--int insertMessage(Message message);-->
<insert id="insertMessage" parameterType="Message" keyProperty="id">
    insert into message(<include refid="insertFields"></include>)
    values(#{fromId},#{toId},#{conversationId},#{content},#{status},#{createTime})
</insert>

<!--修改消息的状态，是已读还是未读-->
<!--int updateStatus(List<Integer> ids, int status);-->
<update id="updateStatus">
    update message set status = #{status}
    where id in
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</update>

<!--查询未读私信的数量-->
<!--int selectLetterUnreadCount(int userId, String conversationId);-->
<select id="selectLetterUnreadCount" resultType="int">
    select count(id)
    from message
    where status = 0
    and from_id != 1
    and to_id = #{userId}
    <if test="conversationId!=null">
        and conversation_id = #{conversationId}
    </if>
</select>
```

第二步：service层（MessageService类）

```java
@Autowired
private MessageMapper messageMapper;

@Autowired
private SensitiveFilter sensitiveFilter;
/**
     * 添加消息，即发送私信
     * @param message 消息对象
     * @return 返回成功条数
     */
public int addMessage(Message message) {
    //防止转义字符
    message.setContent(HtmlUtils.htmlEscape(message.getContent()));
    //敏感词的过滤
    message.setContent(sensitiveFilter.filter(message.getContent()));
    return messageMapper.insertMessage(message);
}

/**
     * 获取消息，将消息从未读的状态改成已读的形式
     * @param ids 消息
     * @return 成功条数
     */
public int readMessage(List<Integer> ids) {
    //将状态改为1表示已读的形式
    return messageMapper.updateStatus(ids, 1);
}
```

UserService类：

```java
/**
 * 通过用户名查找用户
 * @param username 用户名
 * @return 用户对象
 */
public User findUserByName(String username){
    return userMapper.selectByName(username);
}
```

第三步：controller层（MessageController类）

```java
/**
     * 发送私信
     * @param toName 发送给谁
     * @param content 发送的内容是什么
     * @return
     */
@RequestMapping(path = "/letter/send", method = RequestMethod.POST)
@ResponseBody
public String sendLetter(String toName, String content) {
    //通过用户名查找用户对象
    User target = userService.findUserByName(toName);
    if (target == null) {
        return CommunityUtil.getJSONString(1, "目标用户不存在!");
    }

    Message message = new Message();
    //发送者的id
    message.setFromId(hostHolder.getUser().getId());
    //接收者的id
    message.setToId(target.getId());
    //现在需要来拼一个conversionId（会话id）
    //要求id小的在前，大的在后
    if (message.getFromId() < message.getToId()) {
        message.setConversationId(message.getFromId() + "_" + message.getToId());
    } else {
        message.setConversationId(message.getToId() + "_" + message.getFromId());
    }
    //私信内容
    message.setContent(content);
    //发送时间
    message.setCreateTime(new Date());
    //私信的插入
    messageService.addMessage(message);

    //没有报错的话将返回0
    //报错的话，以后统一处理异常
    return CommunityUtil.getJSONString(0);
}

/**
     * 获取未读的消息，为了将未读的消息自动设置成已读的消息
     * @param letterList 消息列表
     * @return 获取未读的消息
     */
private List<Integer> getLetterIds(List<Message> letterList) {
    List<Integer> ids = new ArrayList<>();

    if (letterList != null) {
        for (Message message : letterList) {
            if (hostHolder.getUser().getId() == message.getToId() && message.getStatus() == 0) {
                ids.add(message.getId());
            }
        }
    }

    return ids;
}
```

前端页面：这里需要注意的是私信页面和私信详情页面上面都是由发送私信的功能的

私信页面（letter.html）

首先需要在letter.js中的send_letter方法中加入如下的代码，表示由谁发送给谁

```js
var toName = $("#recipient-name").val();
var content = $("#message-text").val();
$.post(
    CONTEXT_PATH + "/letter/send",
    {"toName":toName,"content":content},
    function(data) {
        data = $.parseJSON(data);
        if(data.code == 0) {
            $("#hintBody").text("发送成功!");
        } else {
            $("#hintBody").text(data.msg);
        }
        );
```

私信详情页面（letter-detail.html）

![image-20220619223506073](D:\Typora\File\nowcode_community\image-20220619223506073.png)

显示的效果：

![image-20220619224804548](D:\Typora\File\nowcode_community\image-20220619224804548.png)

![image-20220619224837712](D:\Typora\File\nowcode_community\image-20220619224837712.png)

在MessageController中的getLetterDetail方法中加上这一段，目的是为了在进入私信的时候，自动将未读的状态改成已读的状态

```java
//将未读的消息设置成已读的消息
List<Integer> ids = getLetterIds(letterList);
if(!ids.isEmpty()){
    messageService.readMessage(ids);
}
```

![image-20220619224540659](D:\Typora\File\nowcode_community\image-20220619224540659.png)

点进去，再退出来的时候就没有这个未读消息的提示了，并且下次再进入的时候就不会再执行更新状态了

![image-20220619224637626](D:\Typora\File\nowcode_community\image-20220619224637626.png)

### 第九节，统一处理异常

- @ControllerAdvice 
  -  用于修饰类，表示该类是Controller的全局配置类。 
  -  在此类中，可以对Controller进行如下三种全局配置： 异常处理方案、绑定数据方案、绑定参数方案。 
- @ExceptionHandler 
  -  用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。 
-  @ModelAttribute 
  - 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。 
-  @DataBinder 
  -  用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器

​	SpringBoot提供了统一日志处理，我们只需要将error目录放在templates目录下面，然后将错误的类型的html放在error，当我们出现相应的错误的时候就会自动跳转到相应的页面。

<img src="D:\Typora\File\nowcode_community\image-20220611204306417.png" alt="image-20220611204306417" style="zoom:67%;" />

当我们需要记录日志的时候，就需要使用到Spring了。

​		创建ExceptionAdvice异常通知类，针对所有的controller类，当出现异常的时候，我们就会判断是普通的异常还是异步异常，然后在控制台来记录异常。

```java
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    @ExceptionHandler({Exception.class})
    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error("服务器发生异常: " + e.getMessage());
        for (StackTraceElement element : e.getStackTrace()) {
            logger.error(element.toString());
        }

        //判断是普通的异常还是异步的异常
        String xRequestedWith = request.getHeader("x-requested-with");
        if ("XMLHttpRequest".equals(xRequestedWith)) {
            response.setContentType("application/plain;charset=utf-8");
            PrintWriter writer = response.getWriter();
            writer.write(CommunityUtil.getJSONString(1, "服务器异常!"));
        } else {
            response.sendRedirect(request.getContextPath() + "/error");
        }
    }
}
```

然后我们就可以在代码中制造一些错误进行测试

![image-20220619232051472](D:\Typora\File\nowcode_community\image-20220619232051472.png)

这个时候我们不仅可以在前端看到异常，而且在后端也会记录日志

![image-20220619232001881](D:\Typora\File\nowcode_community\image-20220619232001881.png)

### 第十节，统一记录日志

![image-20220611194502077](D:\Typora\File\nowcode_community\image-20220611194502077.png)

AOP的概念

Aspect Oriented Programing， 即面向方面（切面）编程。 

AOP是一种编程思想，是对OOP的补充， 可以进一步提高编程的效率



![image-20220611194617025](D:\Typora\File\nowcode_community\image-20220611194617025.png)

AOP的实现 

- AspectJ 
  - AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。 
  - AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。 
- Spring AOP 
  - Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。 
  - Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。 
  - Spring支持对AspectJ的集成



Spring AOP 

-  JDK动态代理 
  -  Java提供的动态代理技术，可以在运行时创建接口的代理实例。 
  -  Spring AOP默认采用此种方式，在接口的代理实例中织入代码。
-  CGLib动态代理 
  -  采用底层的字节码技术，在运行时创建子类代理实例。 
  - 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。



#### 1，示例

```java
@Component
@Aspect
public class AlphaAspect {

    //pointcut切点方法不用写任何逻辑是规范,仅仅是为了定义一个切点而已,逻辑都在那个注解上。
    //下面都是使用的这个注解来实现对具体的方法实现切入的
    //方法的返回值+com.nowcoder.community.service（包名）+方法类+方法名（参数）
    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    //在实例方法之前调用的时候执行
    @Before("pointcut()")
    public void before() {
        System.out.println("before");
    }

    //在实例方法之后调用的时候执行
    @After("pointcut()")
    public void after() {
        System.out.println("after");
    }

    //在实例方法有返回值之后的时候执行
    @AfterReturning("pointcut()")
    public void afterRetuning() {
        System.out.println("afterRetuning");
    }

    //在实例方法抛异常的时候执行
    @AfterThrowing("pointcut()")
    public void afterThrowing() {
        System.out.println("afterThrowing");
    }

    //在实例方法的前后调用的时候都执行
    @Around("pointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("around before");
        Object obj = joinPoint.proceed();
        System.out.println("around after");
        return obj;
    }

}
```

下面我们来刷新一下页面，然后来看一下具体的调用顺序：

```
around before
before
afterRetuning
after
around after
```

#### 2，实践

```java
@Component
@Aspect
public class ServiceLogAspect {

    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    //joinPoint表示连接点
    public void before(JoinPoint joinPoint) {
        // 用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()].
        //用户的ip地址在某个时间点访问了某个功能
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        logger.info(String.format("用户[%s],在[%s],访问了[%s].", ip, now, target));
    }
}
```

## 第四章，Redis，一站式高性能存储方案

### 第一节，Redis入门

- Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构： 字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。
-  Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。 同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。
- Redis典型的应用场景包括：缓存、排行榜、计数器、社交网络、消息队列等。

参考网站：

https://redis.io 

https://github.com/microsoftarchive/redis



### 第二节，Spring整合Redis

- 引入依赖：由于StringBoot已经整只需要配置这个starter包即可
  - spring-boot-starter-data-redis 

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

- 配置Redis

  -  配置数据库参数

  ```properties
  # RedisProperties
  spring.redis.database=1
  spring.redis.host=localhost
  spring.redis.port=6379
  ```

  

  -  编写配置类，构造RedisTemplate

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // 设置key的序列化方式
        template.setKeySerializer(RedisSerializer.string());
        // 设置value的序列化方式
        template.setValueSerializer(RedisSerializer.json());
        // 设置hash的key的序列化方式
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置hash的value的序列化方式
        template.setHashValueSerializer(RedisSerializer.json());

        template.afterPropertiesSet();
        return template;
    }

}
```

测试redis

- 访问Redis 

  -  redisTemplate.opsForValue()

  -  redisTemplate.opsForHash()

  -  redisTemplate.opsForList()

  -  redisTemplate.opsForSet() 

  -  redisTemplate.opsForZSet()

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class RedisTests {

    @Autowired
    private RedisTemplate redisTemplate;

    //对String类型的数据进行操作操作
    @Test
    public void testStrings() {
        String redisKey = "test:count";

        redisTemplate.opsForValue().set(redisKey, 1);

        System.out.println(redisTemplate.opsForValue().get(redisKey));
        System.out.println(redisTemplate.opsForValue().increment(redisKey));
        System.out.println(redisTemplate.opsForValue().decrement(redisKey));
    }

    //对Hash类型的数据进行操作
    @Test
    public void testHashes() {
        String redisKey = "test:user";

        redisTemplate.opsForHash().put(redisKey, "id", 1);
        redisTemplate.opsForHash().put(redisKey, "username", "zhangsan");

        System.out.println(redisTemplate.opsForHash().get(redisKey, "id"));
        System.out.println(redisTemplate.opsForHash().get(redisKey, "username"));
    }

    //对列表类型的数据进行操作
    @Test
    public void testLists() {
        String redisKey = "test:ids";

        redisTemplate.opsForList().leftPush(redisKey, 101);
        redisTemplate.opsForList().leftPush(redisKey, 102);
        redisTemplate.opsForList().leftPush(redisKey, 103);

        System.out.println(redisTemplate.opsForList().size(redisKey));
        System.out.println(redisTemplate.opsForList().index(redisKey, 0));
        System.out.println(redisTemplate.opsForList().range(redisKey, 0, 2));

        System.out.println(redisTemplate.opsForList().leftPop(redisKey));
        System.out.println(redisTemplate.opsForList().leftPop(redisKey));
        System.out.println(redisTemplate.opsForList().leftPop(redisKey));
    }

    //对集合类型的数据进行操作
    @Test
    public void testSets() {
        String redisKey = "test:teachers";

        redisTemplate.opsForSet().add(redisKey, "刘备", "关羽", "张飞", "赵云", "诸葛亮");

        System.out.println(redisTemplate.opsForSet().size(redisKey));
        System.out.println(redisTemplate.opsForSet().pop(redisKey));
        System.out.println(redisTemplate.opsForSet().members(redisKey));
    }

    //对有序集合中的数据进行操作
    @Test
    public void testSortedSets() {
        String redisKey = "test:students";

        redisTemplate.opsForZSet().add(redisKey, "唐僧", 80);
        redisTemplate.opsForZSet().add(redisKey, "悟空", 90);
        redisTemplate.opsForZSet().add(redisKey, "八戒", 50);
        redisTemplate.opsForZSet().add(redisKey, "沙僧", 70);
        redisTemplate.opsForZSet().add(redisKey, "白龙马", 60);

        System.out.println(redisTemplate.opsForZSet().zCard(redisKey));
        System.out.println(redisTemplate.opsForZSet().score(redisKey, "八戒"));
        System.out.println(redisTemplate.opsForZSet().reverseRank(redisKey, "八戒"));
        System.out.println(redisTemplate.opsForZSet().reverseRange(redisKey, 0, 2));
    }

    //对键进行操作
    @Test
    public void testKeys() {
        redisTemplate.delete("test:user");

        System.out.println(redisTemplate.hasKey("test:user"));

        redisTemplate.expire("test:students", 10, TimeUnit.SECONDS);
    }

    // 批量发送命令,节约网络开销.
    @Test
    public void testBoundOperations() {
        String redisKey = "test:count";
        BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);
        operations.increment();
        operations.increment();
        operations.increment();
        operations.increment();
        operations.increment();
        System.out.println(operations.get());
    }

    // 编程式事务
    @Test
    public void testTransaction() {
        Object result = redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations redisOperations) throws DataAccessException {
                String redisKey = "text:tx";

                // 启用事务
                redisOperations.multi();
                redisOperations.opsForSet().add(redisKey, "zhangsan");
                redisOperations.opsForSet().add(redisKey, "lisi");
                redisOperations.opsForSet().add(redisKey, "wangwu");

                System.out.println(redisOperations.opsForSet().members(redisKey));

                // 提交事务
                return redisOperations.exec();
            }
        });
        System.out.println(result);
    }
}
```

### 第三节，点赞

- 点赞 
  - 支持对帖子、评论点赞。 
  -  第1次点赞，第2次取消点赞。
- 首页点赞数量 
  -  统计帖子的点赞数量。
-  详情页点赞数量
  - 统计点赞数量。 
  - 显示点赞状态

点赞评论的访问评论是非常高的，因此我们需要去考虑性能的问题，因此我们就这个点赞的数据放到内存里面就会快得多了

我们在操作redis的时候是不需要专门去声明数据访问层的，我们可以直接写业务层，在写业务层之前，我们需要写一个生成key的工具类

第一步：编写工具类

```java
public class RedisKeyUtil {

    private static final String SPLIT = ":";
    private static final String PREFIX_ENTITY_LIKE = "like:entity";

    // 某个实体的赞
    // like:entity:entityType:entityId -> set(userId)
    public static String getEntityLikeKey(int entityType, int entityId) {
        return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;
    }

}
```

第二步：编写业务层（LikeService类）

```java
//like是喜欢的意思，也就是点赞
@Service
public class LikeService {

    @Autowired
    private RedisTemplate redisTemplate;

    // 点赞
    public void like(int userId, int entityType, int entityId) {
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
        boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);
        if (isMember) {
            redisTemplate.opsForSet().remove(entityLikeKey, userId);
        } else {
            redisTemplate.opsForSet().add(entityLikeKey, userId);
        }
    }

    // 查询某实体点赞的数量
    public long findEntityLikeCount(int entityType, int entityId) {
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
        return redisTemplate.opsForSet().size(entityLikeKey);
    }

    // 查询某人对某实体的点赞状态
    public int findEntityLikeStatus(int userId, int entityType, int entityId) {
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;
    }
}
```

第三步：编写表述层（LikeController类）

```java
@Controller
public class LikeController {

    @Autowired
    private LikeService likeService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(path = "/like", method = RequestMethod.POST)
    @ResponseBody
    public String like(int entityType, int entityId) {
        User user = hostHolder.getUser();

        // 点赞
        likeService.like(user.getId(), entityType, entityId);

        // 数量
        long likeCount = likeService.findEntityLikeCount(entityType, entityId);
        // 状态
        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);
        // 返回的结果
        Map<String, Object> map = new HashMap<>();
        map.put("likeCount", likeCount);
        map.put("likeStatus", likeStatus);

        return CommunityUtil.getJSONString(0, null, map);
    }

}
```

帖子详情页面的前端页面，里面有三个地方涉及到了点赞的地方，分别是帖子，评论和回复（discuss-detail.html）

![image-20220620133907011](D:\Typora\File\nowcode_community\image-20220620133907011.png)

![image-20220620133943374](D:\Typora\File\nowcode_community\image-20220620133943374.png)

![image-20220620134015614](D:\Typora\File\nowcode_community\image-20220620134015614.png)

下面我们将自己写一个js（discuss.js）

```js
function like(btn, entityType, entityId, entityUserId, postId) {
    $.post(
        CONTEXT_PATH + "/like",
        {"entityType":entityType,"entityId":entityId,"entityUserId":entityUserId,"postId":postId},
        function(data) {
            data = $.parseJSON(data);
            if(data.code == 0) {
                $(btn).children("i").text(data.likeCount);
                $(btn).children("b").text(data.likeStatus==1?'已赞':"赞");
            } else {
                alert(data.msg);
            }
        }
    );
}
```

第四步：另外，我们需要在首页和详情页面显示赞的数量

因此在首页的controller（HomeController）中的getIndexPage方法中加入以下内容

因为我们在查询帖子的过程中查该帖子赞的数量

```java
@Autowired
private LikeService likeService;
long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());
map.put("likeCount", likeCount);
```

在帖子页面的controller（DiscussPostController）中的getDiscussPost方法加入

```java
@Autowired
private LikeService likeService;

//获取帖子的点赞
// 点赞数量
long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);
model.addAttribute("likeCount", likeCount);
// 点赞状态
int likeStatus = hostHolder.getUser() == null ? 0 :
likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);
model.addAttribute("likeStatus", likeStatus);


//获取评论的点赞
// 点赞数量
likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());
commentVo.put("likeCount", likeCount);
// 点赞状态
likeStatus = hostHolder.getUser() == null ? 0 :
likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());
commentVo.put("likeStatus", likeStatus);


//获取回复的点赞
// 点赞数量
likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());
replyVo.put("likeCount", likeCount);
// 点赞状态
likeStatus = hostHolder.getUser() == null ? 0 :
likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());
replyVo.put("likeStatus", likeStatus);
```

前端页面：(discuss-detail.html)

在详情页面上面需要有三个赞的地方，分别是帖子的赞，评论的赞和回复的赞

![image-20220620142622822](D:\Typora\File\nowcode_community\image-20220620142622822.png)

![image-20220620142650976](D:\Typora\File\nowcode_community\image-20220620142650976.png)

![image-20220620142720345](D:\Typora\File\nowcode_community\image-20220620142720345.png)

### 第四节，我收到的赞

- 重构点赞功能
  -  以用户为key，记录点赞数量
  - increment(key)，decrement(key) 

- 开发个人主页 

  - 以用户为key，查询点赞数量

  - 显示个人主页中自己所获得的赞

将某个实体的赞转换成某个用户的赞(RedisKeyUtil类)

```java
private static final String PREFIX_USER_LIKE = "like:user";

// 某个用户的赞
// like:user:userId -> int
public static String getUserLikeKey(int userId) {
    return PREFIX_USER_LIKE + SPLIT + userId;
}
```

业务逻辑层（LikeService类）

```java
// 点赞
public void like(int userId, int entityType, int entityId, int entityUserId) {
    redisTemplate.execute(new SessionCallback() {
        @Override
        public Object execute(RedisOperations operations) throws DataAccessException {
            String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
            String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);
            boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);
            operations.multi();
            if (isMember) {
                operations.opsForSet().remove(entityLikeKey, userId);
                operations.opsForValue().decrement(userLikeKey);
            } else {
                operations.opsForSet().add(entityLikeKey, userId);
                operations.opsForValue().increment(userLikeKey);
            }
            return operations.exec();
        }
    });
}


// 查询某个用户获得的赞
public int findUserLikeCount(int userId) {
    String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);
    Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);
    return count == null ? 0 : count.intValue();
}
```

表述层

再UserController中写一个跳转到profile页面的方法（getProfilePage方法）：

```java
@Autowired
private LikeService likeService;

/**
 * 个人主页
 * @param userId 用户id
 * @param model model
 * @return
 */
@RequestMapping(path = "/profile/{userId}", method = RequestMethod.GET)
public String getProfilePage(@PathVariable("userId") int userId, Model model) {
    User user = userService.findUserById(userId);
    if (user == null) {
        throw new RuntimeException("该用户不存在!");
    }

    // 用户
    model.addAttribute("user", user);
    // 载跳转之后也是显示点赞数量
    int likeCount = likeService.findUserLikeCount(userId);
    model.addAttribute("likeCount", likeCount);

    return "/site/profile";
}
```

前端页面

index.html页面用来跳转到profile页面：

![image-20220620150059171](D:\Typora\File\nowcode_community\image-20220620150059171.png)

在profile个人主页的详情页面：

![image-20220612151707840](C:\Users\20948\AppData\Roaming\Typora\typora-user-images\image-20220612151707840.png)

### 第五节，关注，取消关注

- 需求
  -  开发关注、取消关注功能。
  - 统计用户的关注数、粉丝数。
- 关键 
  - 若A关注了B，则A是B的Follower（粉丝），B是A的Followee（目标）。 
  - 关注的目标可以是用户、帖子、题目等，在实现时将这些目标抽象为实体。

因为我们需要将数据存储到redis中，所以

第一步：编写redis的工具类（RedisKeyUtil类）

```java
private static final String PREFIX_FOLLOWEE = "followee";
private static final String PREFIX_FOLLOWER = "follower";
// 某个用户关注的实体
// followee:userId:entityType -> zset(entityId,now)
public static String getFolloweeKey(int userId, int entityType) {
return PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;
}

// 某个实体拥有的粉丝
// follower:entityType:entityId -> zset(userId,now)
public static String getFollowerKey(int entityType, int entityId) {
return PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;
}
```

第二步：编写service层（FollowService类）

```java
@Service
public class FollowService {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 关注用户
     * @param userId 用户id
     * @param entityType 实体类型
     * @param entityId 实体id
     */
    public void follow(int userId, int entityType, int entityId) {
        redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);
                operations.multi();
                operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());
                operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());

                return operations.exec();
            }
        });
    }

    /**
     * 取关用户
     * @param userId 用户id
     * @param entityType 实体类型
     * @param entityId 实体id
     */
    public void unfollow(int userId, int entityType, int entityId) {
        redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
                String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);
                operations.multi();
                operations.opsForZSet().remove(followeeKey, entityId);
                operations.opsForZSet().remove(followerKey, userId);
                return operations.exec();
            }
        });
    }

    /**
     * 查询关注的实体的数量
     * @param userId 用户id
     * @param entityType 实体类型
     * @return 返回关注的实体数量
     */
    public long findFolloweeCount(int userId, int entityType) {
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
        return redisTemplate.opsForZSet().zCard(followeeKey);
    }

    /**
     * 查询实体的粉丝的数量
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return 返回实体的粉丝的数量
     */
    public long findFollowerCount(int entityType, int entityId) {
        String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);
        return redisTemplate.opsForZSet().zCard(followerKey);
    }

    /**
     * 查询当前用户是否已关注该实体
     * @param userId 用户id
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return 返回前用户是否已关注该实体
     */
    public boolean hasFollowed(int userId, int entityType, int entityId) {
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
        return redisTemplate.opsForZSet().score(followeeKey, entityId) != null;
    }
}
```

第三步：编写controller层

```java
@Controller
public class FollowController {

    @Autowired
    private FollowService followService;

    @Autowired
    private HostHolder hostHolder;

    /**
     * 关注的动作
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return 
     */
    @RequestMapping(path = "/follow", method = RequestMethod.POST)
    @ResponseBody
    public String follow(int entityType, int entityId) {
        User user = hostHolder.getUser();

        followService.follow(user.getId(), entityType, entityId);

        return CommunityUtil.getJSONString(0, "已关注!");
    }

    /**
     * 取消关注的动作
     * @param entityType 实体类型
     * @param entityId 实体id
     * @return
     */
    @RequestMapping(path = "/unfollow", method = RequestMethod.POST)
    @ResponseBody
    public String unfollow(int entityType, int entityId) {
        User user = hostHolder.getUser();

        followService.unfollow(user.getId(), entityType, entityId);

        return CommunityUtil.getJSONString(0, "已取消关注!");
    }

}
```

前端页面：

需要编写一段js代码，用来显示关注与取消关注（profile.js）

```js
$(function(){
	$(".follow-btn").click(follow);
});

function follow() {
	var btn = this;
	if($(btn).hasClass("btn-info")) {
		// 关注TA
		$.post(
			CONTEXT_PATH + "/follow",
			{"entityType":3,"entityId":$(btn).prev().val()},
			function(data) {
				data = $.parseJSON(data);
				if(data.code == 0) {
					window.location.reload();
				} else {
					alert(data.msg);
				}
			}
		);
		// $(btn).text("已关注").removeClass("btn-info").addClass("btn-secondary");
	} else {
		// 取消关注
		$.post(
			CONTEXT_PATH + "/unfollow",
			{"entityType":3,"entityId":$(btn).prev().val()},
			function(data) {
				data = $.parseJSON(data);
				if(data.code == 0) {
					window.location.reload();
				} else {
					alert(data.msg);
				}
			}
		);
		//$(btn).text("关注TA").removeClass("btn-secondary").addClass("btn-info");
	}
}
```

UserController类中的getProfilePage方法中加上以下代码：

```java
// 关注数量
long followeeCount = followService.findFolloweeCount(userId, ENTITY_TYPE_USER);
model.addAttribute("followeeCount", followeeCount);
// 粉丝数量
long followerCount = followService.findFollowerCount(ENTITY_TYPE_USER, userId);
model.addAttribute("followerCount", followerCount);
// 是否已关注
boolean hasFollowed = false;
if (hostHolder.getUser() != null) {
    hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);
}
model.addAttribute("hasFollowed", hasFollowed);
```

![image-20220620213159579](D:\Typora\File\nowcode_community\image-20220620213159579.png)

在profile.html页面上面可以写上用户关注的情况

![image-20220612161425856](D:\Typora\File\nowcode_community\image-20220612161425856.png)

最后显示的效果是：

![image-20220620213409493](D:\Typora\File\nowcode_community\image-20220620213409493.png)

### 第六节，关注列表、粉丝列表

- 业务层 
  -  查询某个用户关注的人，支持分页。 
  - 查询某个用户的粉丝，支持分页。
- 表现层
  -  处理“查询关注的人”、“查询粉丝”请求。
  - 编写“查询关注的人”、“查询粉丝”模板。

第一步：编写业务层（FollowService类）

```java
/**
     * 查询某用户关注的人
     * @param userId 用户id
     * @param offset 偏移量
     * @param limit 每页显示的数量
     * @return
     */
public List<Map<String, Object>> findFollowees(int userId, int offset, int limit) {
    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);
    Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - 1);

    if (targetIds == null) {
        return null;
    }

    List<Map<String, Object>> list = new ArrayList<>();
    for (Integer targetId : targetIds) {
        Map<String, Object> map = new HashMap<>();
        User user = userService.findUserById(targetId);
        map.put("user", user);
        Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);
        map.put("followTime", new Date(score.longValue()));
        list.add(map);
    }

    return list;
}

/**
     * 查询某用户的粉丝
     * @param userId 用户id
     * @param offset 偏移量
     * @param limit 每页显示的数量
     * @return
     */
public List<Map<String, Object>> findFollowers(int userId, int offset, int limit) {
    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);
    Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);

    if (targetIds == null) {
        return null;
    }

    List<Map<String, Object>> list = new ArrayList<>();
    for (Integer targetId : targetIds) {
        Map<String, Object> map = new HashMap<>();
        User user = userService.findUserById(targetId);
        map.put("user", user);
        Double score = redisTemplate.opsForZSet().score(followerKey, targetId);
        map.put("followTime", new Date(score.longValue()));
        list.add(map);
    }

    return list;
}
```

第二步：编写Controller层（FollowController类）

```java
@Autowired
private UserService userService;

/**
     * 获取用户关注的人
     * @param userId 用户id
     * @param page 分页
     * @param model model
     * @return
     */
@RequestMapping(path = "/followees/{userId}", method = RequestMethod.GET)
public String getFollowees(@PathVariable("userId") int userId, Page page, Model model) {
    User user = userService.findUserById(userId);
    if (user == null) {
        throw new RuntimeException("该用户不存在!");
    }
    model.addAttribute("user", user);

    page.setLimit(5);
    page.setPath("/followees/" + userId);
    page.setRows((int) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));

    List<Map<String, Object>> userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());
    if (userList != null) {
        for (Map<String, Object> map : userList) {
            User u = (User) map.get("user");
            map.put("hasFollowed", hasFollowed(u.getId()));
        }
    }
    model.addAttribute("users", userList);
    return "/site/followee";
}

/**
     * 获取粉丝（关注你的人）
     * @param userId 用户id
     * @param page 分页
     * @param model model
     * @return
     */
@RequestMapping(path = "/followers/{userId}", method = RequestMethod.GET)
public String getFollowers(@PathVariable("userId") int userId, Page page, Model model) {
    User user = userService.findUserById(userId);
    if (user == null) {
        throw new RuntimeException("该用户不存在!");
    }
    model.addAttribute("user", user);
    page.setLimit(5);
    page.setPath("/followers/" + userId);
    page.setRows((int) followService.findFollowerCount(ENTITY_TYPE_USER, userId));

    List<Map<String, Object>> userList = followService.findFollowers(userId, page.getOffset(), page.getLimit());
    if (userList != null) {
        for (Map<String, Object> map : userList) {
            User u = (User) map.get("user");
            map.put("hasFollowed", hasFollowed(u.getId()));
        }
    }
    model.addAttribute("users", userList);

    return "/site/follower";
}

/**
     * 判断当前用户是否已经关注了
     * @param userId 用户id
     * @return
     */
private boolean hasFollowed(int userId) {
    if (hostHolder.getUser() == null) {
        return false;
    }
    return followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);
}
```

前端页面

个人主页页面（profile.html）

![image-20220612184839580](D:\Typora\File\nowcode_community\image-20220612184839580.png)

用户关注的人页面（followee.html）

![image-20220612185852284](D:\Typora\File\nowcode_community\image-20220612185852284.png)

关注用户的人页面（follower.html）

![image-20220612190154184](D:\Typora\File\nowcode_community\image-20220612190154184.png)

### 第七节，优化登录模块

- 使用Redis存储验证码
  -  验证码需要频繁的访问与刷新，对性能要求较高。
  - 验证码不需永久保存，通常在很短的时间后就会失效。 
  - 分布式部署时，存在Session共享的问题。
- 使用Redis存储登录凭证 
  - 处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。 
- 使用Redis缓存用户信息
  - 处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。

首先创建redis的key（RedisKeyUtil类）

```java
private static final String PREFIX_KAPTCHA = "kaptcha";
private static final String PREFIX_TICKET = "ticket";
private static final String PREFIX_USER = "user";
// 登录验证码
public static String getKaptchaKey(String owner) {
return PREFIX_KAPTCHA + SPLIT + owner;
}

// 登录的凭证
public static String getTicketKey(String ticket) {
return PREFIX_TICKET + SPLIT + ticket;
}

// 用户
public static String getUserKey(int userId) {
return PREFIX_USER + SPLIT + userId;
}
```

下面我们先来演示以下使用Redis存储验证码：

修改controller层（LoginController类），将信息不存到cookie中了，改为存到redis中

<img src="D:\Typora\File\nowcode_community\image-20220621234822732.png" alt="image-20220621234822732" style="zoom:80%;" />

<img src="D:\Typora\File\nowcode_community\image-20220621235154237.png" alt="image-20220621235154237" style="zoom:67%;" />

下面我们再来演示一下使用Redis存储登录凭证和使用Redis缓存用户信息：

首先我们在LoginTicketMapper接口上面使用@Deprecated注解，表示将该接口废弃掉，就是我们不会从数据库中取登陆凭证，而是优先从redis中取这个登陆凭证

修改service层，即把登陆凭证以及其他的登录信息从cookie中换到redis中进行保存

将方法中的画//的部分去掉，然后在下面加上一下内容即可，另外需要补充三个方法：getCache、initCache、clearCache

```java
@Service
public class UserService implements CommunityConstant {

    @Autowired
    private UserMapper userMapper;

    /**
     * 用于发送邮件
     */
    @Autowired
    private MailClient mailClient;

    /**
     * 模板引擎
     */
    @Autowired
    private TemplateEngine templateEngine;

    /**
     * 用户登录
     */
    //@Autowired
    //private LoginTicketMapper loginTicketMapper;
    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 域名（本地地址）
     */
    @Value("${community.path.domain}")
    private String domain;

    /**
     * 访问路径
     */
    @Value("${server.servlet.context-path}")
    private String contextPath;


    public User findUserById(int id){
        //return userMapper.selectById(id);
        User user = getCache(id);
        if (user == null) {
            user = initCache(id);
        }
        return user;
    }

    /**
     * 用户用户注册的业务逻辑层
     * @param user 用户对象
     * @return
     */
    public Map<String, Object> register(User user){

        Map<String, Object> map = new HashMap<>();

        // 空值处理
        if (user == null) {
            throw new IllegalArgumentException("参数不能为空!");
        }
        if (StringUtils.isBlank(user.getUsername())) {
            map.put("usernameMsg", "账号不能为空!");
            return map;
        }
        if (StringUtils.isBlank(user.getPassword())) {
            map.put("passwordMsg", "密码不能为空!");
            return map;
        }
        if (StringUtils.isBlank(user.getEmail())) {
            map.put("emailMsg", "邮箱不能为空!");
            return map;
        }

        // 验证账号
        User u = userMapper.selectByName(user.getUsername());
        if (u != null) {
            map.put("usernameMsg", "该账号已存在!");
            return map;
        }

        // 验证邮箱
        u = userMapper.selectByEmail(user.getEmail());
        if (u != null) {
            map.put("emailMsg", "该邮箱已被注册!");
            return map;
        }

        // 注册用户
        user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
        user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));
        user.setType(0);
        user.setStatus(0);
        user.setActivationCode(CommunityUtil.generateUUID());
        user.setHeaderUrl(String.format("http://images.nowcoder.com/head/%dt.png", new Random().nextInt(1000)));
        user.setCreateTime(new Date());
        userMapper.insertUser(user);

        // 激活邮件(html邮件)
        Context context = new Context();
        context.setVariable("email", user.getEmail());
        // http://localhost:8080/community/activation/101/code
        String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode();
        context.setVariable("url", url);
        String content = templateEngine.process("/mail/activation", context);
        mailClient.sendMail(user.getEmail(), "激活账号", content);

        return map;

    }

    /**
     * 用户激活的业务逻辑层
     * @param userId
     * @param code
     * @return
     */
    public int activation(int userId, String code) {
        User user = userMapper.selectById(userId);
        if (user.getStatus() == 1) {
            return ACTIVATION_REPEAT;
        } else if (user.getActivationCode().equals(code)) {
            userMapper.updateStatus(userId, 1);
            return ACTIVATION_SUCCESS;
        } else {
            return ACTIVATION_FAILURE;
        }
    }

    /**
     * 用户登录的业务逻辑层
     * @param username 用户名
     * @param password 密码
     * @param expiredSeconds
     * @return
     */
    public Map<String, Object> login(String username, String password, int expiredSeconds) {
        Map<String, Object> map = new HashMap<>();

        // 空值处理
        if (StringUtils.isBlank(username)) {
            map.put("usernameMsg", "账号不能为空!");
            return map;
        }
        if (StringUtils.isBlank(password)) {
            map.put("passwordMsg", "密码不能为空!");
            return map;
        }

        // 验证账号
        User user = userMapper.selectByName(username);
        if (user == null) {
            map.put("usernameMsg", "该账号不存在!");
            return map;
        }

        // 验证状态
        if (user.getStatus() == 0) {
            map.put("usernameMsg", "该账号未激活!");
            return map;
        }

        // 验证密码
        password = CommunityUtil.md5(password + user.getSalt());
        if (!user.getPassword().equals(password)) {
            map.put("passwordMsg", "密码不正确!");
            return map;
        }

        //程序运行到这里，表示可以登录成功了，下面就是需要将登陆凭证提交给服务器
        // 生成登录凭证
        LoginTicket loginTicket = new LoginTicket();
        loginTicket.setUserId(user.getId());
        loginTicket.setTicket(CommunityUtil.generateUUID());
        loginTicket.setStatus(0);
        loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));
        //loginTicketMapper.insertLoginTicket(loginTicket);

        String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());
        redisTemplate.opsForValue().set(redisKey, loginTicket);

        map.put("ticket", loginTicket.getTicket());
        return map;
    }

    //退出
    public void logout(String ticket) {
        //loginTicketMapper.updateStatus(ticket, 1);
        String redisKey = RedisKeyUtil.getTicketKey(ticket);
        LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);
        loginTicket.setStatus(1);
        redisTemplate.opsForValue().set(redisKey, loginTicket);

    }

    //根据凭证来查询登录凭证
    public LoginTicket findLoginTicket(String ticket) {
        //return loginTicketMapper.selectByTicket(ticket);
        String redisKey = RedisKeyUtil.getTicketKey(ticket);
        return (LoginTicket) redisTemplate.opsForValue().get(redisKey);
    }

    public int updateHeader(int userId, String headerUrl) {
        //return userMapper.updateHeader(userId, headerUrl);
        int rows = userMapper.updateHeader(userId, headerUrl);
        clearCache(userId);
        return rows;
    }

    public User findUserByName(String username) {
        return userMapper.selectByName(username);
    }

    // 1.优先从缓存中取值
    private User getCache(int userId) {
        String redisKey = RedisKeyUtil.getUserKey(userId);
        return (User) redisTemplate.opsForValue().get(redisKey);
    }

    // 2.取不到时初始化缓存数据
    private User initCache(int userId) {
        User user = userMapper.selectById(userId);
        String redisKey = RedisKeyUtil.getUserKey(userId);
        redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);
        return user;
    }

    // 3.数据变更时清除缓存数据
    private void clearCache(int userId) {
        String redisKey = RedisKeyUtil.getUserKey(userId);
        redisTemplate.delete(redisKey);
    }
}
```

## 第五章，Kafka，构建TB级异步消息系统

### 第一节：阻塞队列

- BlockingQueue 
  - 解决线程通信的问题。
  - 阻塞方法：put、take。 
- 生产者消费者模式 
  -  生产者：产生数据的线程。 
  - 消费者：使用数据的线程。 

​		线程阻塞的好处是：如果我们没有使用阻塞队列，那么即使现在消费者不需要那么多资源的时候，生产者还是会继续生产，生产者生产消息的时候就会消耗系统资源；或者说消费者需要那么多资源的时候，生产者不能生产那么快，消费者等待的时候也是会消耗系统资源的，因此这个时候我们使用阻塞队列，只有队列有消息的时候，消费者才可以去拿消息，只用在队列没有满的时候，生产者才可以去生产消息。

- 实现类 
  - ArrayBlockingQueue 
  - LinkedBlockingQueue
  - PriorityBlockingQueue、SynchronousQueue、DelayQueue等。

阻塞队列的演示使用

```java
public class BlockingQueueTests {

    public static void main(String[] args) {
        BlockingQueue queue = new ArrayBlockingQueue(10);
        new Thread(new Producer(queue),"t1").start();
        new Thread(new Consumer(queue),"t2").start();
        new Thread(new Consumer(queue),"t3").start();
        new Thread(new Consumer(queue),"t4").start();
    }

}

class Producer implements Runnable {

    private BlockingQueue<Integer> queue;

    public Producer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 100; i++) {
                Thread.sleep(20);
                queue.put(i);
                System.out.println(Thread.currentThread().getName() + "生产:" + queue.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

class Consumer implements Runnable {

    private BlockingQueue<Integer> queue;

    public Consumer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) {
                Thread.sleep(new Random().nextInt(1000));
                queue.take();
                System.out.println(Thread.currentThread().getName() + "消费:" + queue.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 第二节，Kafka入门

参考网址：https://kafka.apache.org/

- Kafka简介

  - Kafka是一个分布式的流媒体平台。
  -  应用：消息系统、日志收集、用户行为追踪、流式处理。

- Kafka特点 

  - 高吞吐量、消息持久化、高可靠性、高扩展性。

- Kafka术语 

  -  Broker（Kafka的服务器）、Zookeeper （独立应用，来管理KafKa集群）
  - Topic（消息的消费方式有两种，一种就是点对点的方式，比如上一节说到的阻塞队列就是这样的，生产者从这个阻塞队列中生产数据，消费者从这个阻塞队列里面拿数据，另外一种就是发布订阅模式，生产者生产的消息就叫主题（topic，用来存放消息的位置），可以同时有多个消费者订阅这个消息，比如我们常见的微信公众号）、Partition、Offset 

  ![image-20220612212939706](D:\Typora\File\nowcode_community\image-20220612212939706.png)

  - Leader Replica（主副本） 、Follower Re（从副本）

在发布订阅消息的时候，我们需要首先创建主题

使用步骤：

第一步，启动zookeeper：D:\JAVA\tools\Kafka>bin\windows\zookeeper-server-start.bat config\zookeeper.properties

第二步，启动kafka：D:\JAVA\tools\Kafka>bin\windows\kafka-server-start.bat config\server.properties

第三步，创建主题：D:\JAVA\tools\Kafka\bin\windows>kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test

![image-20220613095533914](D:\Typora\File\nowcode_community\image-20220613095533914.png)

查看创建的主题：kafka-topics.bat --list --bootstrap-server localhost:9092

![image-20220613095741654](D:\Typora\File\nowcode_community\image-20220613095741654.png)

第四步：创建生产者来发送消息：

D:\JAVA\tools\Kafka\bin\windows>kafka-console-producer.bat --broker-list localhost:9092 --topic test

![image-20220613100005937](D:\Typora\File\nowcode_community\image-20220613100005937.png)

第五步：创建消费者来读取消息：

D:\JAVA\tools\Kafka\bin\windows>kafka-console-consumer.bat  --bootstrap-server localhost:9092 --topic test --from-beginning

![image-20220613100612921](D:\Typora\File\nowcode_community\image-20220613100612921.png)

![image-20220613100733091](D:\Typora\File\nowcode_community\image-20220613100733091.png)

### 第三节，Spring整合Kafaka

- 引入依赖 -

  -  spring-kafka 

  ```xml
  <!-- https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka -->
  <dependency>
      <groupId>org.springframework.kafka</groupId>
      <artifactId>spring-kafka</artifactId>
  </dependency>
  ```

-  配置Kafka 

  - 配置server、consumer 

  ```properties
  # KafkaProperties
  spring.kafka.bootstrap-servers=localhost:9092
  spring.kafka.consumer.group-id=community-consumer-group
  spring.kafka.consumer.enable-auto-commit=true
  spring.kafka.consumer.auto-commit-interval=3000
  ```

- 访问Kafka 

  - 生产者 
    - kafkaTemplate.send(topic, data); 
  - 消费者 
    - @KafkaListener(topics = {"test"})
    -  public void handleMessage(ConsumerRecord record) {}

代码演示Kafka

我们一般在实验中将生产者和消费者类进行封装，在这里为了方便，我们写在同一个类中

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class KafkaTests {

    @Autowired
    private KafkaProducer kafkaProducer;

    @Test
    public void testKafka() {
        kafkaProducer.sendMessage("test", "你好");
        kafkaProducer.sendMessage("test", "在吗");

        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

@Component
class KafkaProducer {

    @Autowired
    private KafkaTemplate kafkaTemplate;

    public void sendMessage(String topic, String content) {
        kafkaTemplate.send(topic, content);
    }

}

@Component
class KafkaConsumer {

    @KafkaListener(topics = {"test"})
    public void handleMessage(ConsumerRecord record) {
        System.out.println(record.value());
    }
}
```

此时我们来验证一下消息队列的使用:

![image-20220624210922605](D:\Typora\File\nowcode_community\image-20220624210922605.png)

### 第四节，发送系统通知

- 触发事件 
  - 评论后，发布通知 
  -  点赞后，发布通知 
  - 关注后，发布通知 
-  处理事件 
  - 封装事件对象 
  - 开发事件的生产者 
  - 开发事件的消

![image-20220613101420305](D:\Typora\File\nowcode_community\image-20220613101420305.png)

第一步：编写实体类（Event）

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Event {

    //主题（事件）
    private String topic;
    //事件的触发者（使用者）
    private int userId;
    //事件作用的实体类型
    private int entityType;
    //事件作用的实体id
    private int entityId;
    //实体的作者
    private int entityUserId;
    //让事件具有扩展性
    private Map<String, Object> data = new HashMap<>();
}
```

第二步：编写消息队列的生产者和消费者

生产者：

```java
@Component
public class EventProducer {

    @Autowired
    private KafkaTemplate kafkaTemplate;

    // 处理事件
    public void fireEvent(Event event) {
        // 将事件发布到指定的主题
        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));
    }

}
```

消费者：

```java
@Component
public class EventConsumer implements CommunityConstant {

    private static final Logger logger = LoggerFactory.getLogger(EventConsumer.class);

    @Autowired
    private MessageService messageService;

    @KafkaListener(topics = {TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW})
    public void handleCommentMessage(ConsumerRecord record) {
        if (record == null || record.value() == null) {
            logger.error("消息的内容为空!");
            return;
        }

        Event event = JSONObject.parseObject(record.value().toString(), Event.class);
        if (event == null) {
            logger.error("消息格式错误!");
            return;
        }

        // 发送站内通知
        Message message = new Message();
        message.setFromId(SYSTEM_USER_ID);
        message.setToId(event.getEntityUserId());
        message.setConversationId(event.getTopic());
        message.setCreateTime(new Date());

        Map<String, Object> content = new HashMap<>();
        content.put("userId", event.getUserId());
        content.put("entityType", event.getEntityType());
        content.put("entityId", event.getEntityId());

        if (!event.getData().isEmpty()) {
            for (Map.Entry<String, Object> entry : event.getData().entrySet()) {
                content.put(entry.getKey(), entry.getValue());
            }
        }

        message.setContent(JSONObject.toJSONString(content));
        messageService.addMessage(message);
    }
}
```

第三步：在评论，点赞和关注的controller中加入消息队列

CommentController：

```java
@Autowired
private EventProducer eventProducer;

// 触发评论事件
Event event = new Event()
        .setTopic(TOPIC_COMMENT)
        .setUserId(hostHolder.getUser().getId())
        .setEntityType(comment.getEntityType())
        .setEntityId(comment.getEntityId())
        .setData("postId", discussPostId);
if (comment.getEntityType() == ENTITY_TYPE_POST) {
    DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());
    event.setEntityUserId(target.getUserId());
} else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) {
    Comment target = commentService.findCommentById(comment.getEntityId());
    event.setEntityUserId(target.getUserId());
}
eventProducer.fireEvent(event);
```

LikeController：

```java
@Autowired
private EventProducer eventProducer;

// 触发点赞事件
if (likeStatus == 1) {
    Event event = new Event()
            .setTopic(TOPIC_LIKE)
            .setUserId(hostHolder.getUser().getId())
            .setEntityType(entityType)
            .setEntityId(entityId)
            .setEntityUserId(entityUserId)
            .setData("postId", postId);
    eventProducer.fireEvent(event);
}
```

FollowController：

```java
@Autowired
private EventProducer eventProducer;

// 触发关注事件
Event event = new Event()
        .setTopic(TOPIC_FOLLOW)
        .setUserId(hostHolder.getUser().getId())
        .setEntityType(entityType)
        .setEntityId(entityId)
        .setEntityUserId(entityId);
eventProducer.fireEvent(event);
```

这样我们在评论，点赞和关注的通知就可以在数据库中实现了，下一节我们将在页面上实现

### 第五节，显示系统通知

- 通知列表 
  - 显示评论、点赞、关注三种类型的通知 
- 通知详情 
  - 分页显示某一类主题所包含的通知 
- 未读消息 
  - 在页面头部显示所有的未读消息数量

第一步：编写dao层

MessageMapper接口：

```java
/**
 * 查询某个主题下最新的通知
 * @param userId 用户id
 * @param topic 主题
 * @return 通知对象
 */
Message selectLatestNotice(int userId, String topic);

/**
 * 查询某个主题所包含的通知数量
 * @param userId 用户id
 * @param topic 主题
 * @return 该主题下的通知的条数
 */
int selectNoticeCount(int userId, String topic);

/**
 * 查询未读的通知的数量
 * @param userId 用户id
 * @param topic 主题
 * @return 该主题下未读消息的数量
 */
int selectNoticeUnreadCount(int userId, String topic);
```

Mapper文件（message-mapper.xml）

```xml
<!--查询某个主题下最新的通知-->
<!--Message selectLatestNotice(int userId, String topic);-->
<select id="selectLatestNotice" resultType="Message">
    select <include refid="selectFields"></include>
    from message
    where id in (
    select max(id) from message
    where status != 2
    and from_id = 1
    and to_id = #{userId}
    and conversation_id = #{topic}
    )
</select>

<!--查询某个主题所包含的通知数量-->
<!--int selectNoticeCount(int userId, String topic);-->
<select id="selectNoticeCount" resultType="int">
    select count(id) from message
    where status != 2
    and from_id = 1
    and to_id = #{userId}
      and conversation_id = #{topic}
</select>

<!--查询未读的通知的数量-->
<!--int selectNoticeUnreadCount(int userId, String topic);-->
<select id="selectNoticeUnreadCount" resultType="int">
    select count(id) from message
    where status = 0
    and from_id = 1
    and to_id = #{userId}
    <if test="topic!=null">
        and conversation_id = #{topic}
    </if>
</select>
```

第二步：编写service层：（MessageService类）

```java
/**
 * 查询某个主题下最新的通知
 * @param userId 用户id
 * @param topic 主题
 * @return 该主题下的消息对象
 */
public Message findLatestNotice(int userId, String topic) {
    return messageMapper.selectLatestNotice(userId, topic);
}

/**
 * 查询某个主题所包含的通知数量
 * @param userId 用户id
 * @param topic 主题
 * @return 该主题下的消息数量
 */
public int findNoticeCount(int userId, String topic) {
    return messageMapper.selectNoticeCount(userId, topic);
}

/**
 * 查询未读的通知的数量
 * @param userId 用户id
 * @param topic 主题
 * @return 该主题下未读消息数量
 */
public int findNoticeUnreadCount(int userId, String topic) {
    return messageMapper.selectNoticeUnreadCount(userId, topic);
}
```

第三步：controller类：（MessageController类）

```java
/**
 * 查询某个主题下最新的通知
 * @param model
 * @return
 */
@RequestMapping(path = "/notice/list", method = RequestMethod.GET)
public String getNoticeList(Model model) {
    //获取当前登录的用户
    User user = hostHolder.getUser();

    // 查询评论类通知
    Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);
    Map<String, Object> messageVO = new HashMap<>();
    if (message != null) {
        messageVO.put("message", message);

        String content = HtmlUtils.htmlUnescape(message.getContent());
        Map<String, Object> data = JSONObject.parseObject(content, HashMap.class);

        messageVO.put("user", userService.findUserById((Integer) data.get("userId")));
        messageVO.put("entityType", data.get("entityType"));
        messageVO.put("entityId", data.get("entityId"));
        messageVO.put("postId", data.get("postId"));

        int count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);
        messageVO.put("count", count);

        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);
        messageVO.put("unread", unread);
    }
    model.addAttribute("commentNotice", messageVO);

    // 查询点赞类通知
    message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);
    messageVO = new HashMap<>();
    if (message != null) {
        messageVO.put("message", message);

        String content = HtmlUtils.htmlUnescape(message.getContent());
        Map<String, Object> data = JSONObject.parseObject(content, HashMap.class);

        messageVO.put("user", userService.findUserById((Integer) data.get("userId")));
        messageVO.put("entityType", data.get("entityType"));
        messageVO.put("entityId", data.get("entityId"));
        messageVO.put("postId", data.get("postId"));

        int count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);
        messageVO.put("count", count);

        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);
        messageVO.put("unread", unread);
    }
    model.addAttribute("likeNotice", messageVO);

    // 查询关注类通知
    message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);
    messageVO = new HashMap<>();
    if (message != null) {
        messageVO.put("message", message);

        String content = HtmlUtils.htmlUnescape(message.getContent());
        Map<String, Object> data = JSONObject.parseObject(content, HashMap.class);

        messageVO.put("user", userService.findUserById((Integer) data.get("userId")));
        messageVO.put("entityType", data.get("entityType"));
        messageVO.put("entityId", data.get("entityId"));

        int count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);
        messageVO.put("count", count);

        int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);
        messageVO.put("unread", unread);
    }
    model.addAttribute("followNotice", messageVO);

    // 查询未读消息数量
    int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
    model.addAttribute("letterUnreadCount", letterUnreadCount);
    int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);
    model.addAttribute("noticeUnreadCount", noticeUnreadCount);

    return "/site/notice";
}
```

前端页面：

![image-20220624225800682](D:\Typora\File\nowcode_community\image-20220624225800682.png)

下面我们再来开发通知的详情页面：

第一步：编写dao层：

MessageMapper接口：

```java
/**
 * 查询某个主题所包含的通知列表
 * @param userId 用户id
 * @param topic 主题（评论，赞，关注）
 * @param offset 起始页
 * @param limit 每页显示的数量
 * @return 通知消息对象组成的列表
 */
List<Message> selectNotices(int userId, String topic, int offset, int limit);
```

Mapper文件（message-mapper.xml）

```xml
<select id="selectNotices" resultType="Message">
    select <include refid="selectFields"></include>
    from message
    where status != 2
    and from_id = 1
    and to_id = #{userId}
    and conversation_id = #{topic}
    order by create_time desc
    limit #{offset}, #{limit}
</select>
```

第二步：编写service层（MessageService类）

```java
/**
 * 查询某个主题所包含的通知列表
 * @param userId 用户id
 * @param topic 主题
 * @param offset 起始页
 * @param limit 每页显示的数量
 * @return
 */
public List<Message> findNotices(int userId, String topic, int offset, int limit) {
    return messageMapper.selectNotices(userId, topic, offset, limit);
}
```

第三步：编写controller层（MessageController类）

```java
/**
 * 查询某个主题所包含的通知列表
 * @param topic
 * @param page
 * @param model
 * @return
 */
@RequestMapping(path = "/notice/detail/{topic}", method = RequestMethod.GET)
public String getNoticeDetail(@PathVariable("topic") String topic, Page page, Model model) {
    User user = hostHolder.getUser();

    page.setLimit(5);
    page.setPath("/notice/detail/" + topic);
    page.setRows(messageService.findNoticeCount(user.getId(), topic));

    List<Message> noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());
    List<Map<String, Object>> noticeVoList = new ArrayList<>();
    if (noticeList != null) {
        for (Message notice : noticeList) {
            Map<String, Object> map = new HashMap<>();
            // 通知
            map.put("notice", notice);
            // 内容
            String content = HtmlUtils.htmlUnescape(notice.getContent());
            Map<String, Object> data = JSONObject.parseObject(content, HashMap.class);
            map.put("user", userService.findUserById((Integer) data.get("userId")));
            map.put("entityType", data.get("entityType"));
            map.put("entityId", data.get("entityId"));
            map.put("postId", data.get("postId"));
            // 通知作者
            map.put("fromUser", userService.findUserById(notice.getFromId()));

            noticeVoList.add(map);
        }
    }
    model.addAttribute("notices", noticeVoList);

    // 设置已读
    List<Integer> ids = getLetterIds(noticeList);
    if (!ids.isEmpty()) {
        messageService.readMessage(ids);
    }

    return "/site/notice-detail";
}
```

前端页面：



## 第六章，ElasticSearch，分布式搜索引擎

### 第一节，Elasticsearch入门

参考网站：

https://www.elastic.co 

https://www.getpostman.com

- Elasticsearch简介
  -  一个分布式的、Restful风格的搜索引擎。 
  - 支持对各种类型的数据的检索。
  -  搜索速度快，可以提供实时的搜索服务。
  - 便于水平扩展，每秒可以处理PB级海量数据。
- Elasticsearch术语 
  - 索引（对应mysql中的表）、类型（逐渐废弃）、文档（对应mysql中的行）、字段（对应mysql中的列）。
  -  集群、节点、分片、副本。

我们在安装ElasticSearch之前，需要查看我们的springboot版本和ElasticSearch之间的版本之间的关系，否则会报错，参考网址是：

https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#preface.requirements

![image-20220622102046668](D:\Typora\File\nowcode_community\image-20220622102046668.png)

然后下载一个分词的插件，版本要和es对应，参考网址是https://github.com/medcl/elasticsearch-analysis-ik/releases，然后将这个包解压以后放在ElasticSearch下的plugins下的ik目录下面

下面我们来通过postman来下载测试软件

![image-20220622120453726](D:\Typora\File\nowcode_community\image-20220622120453726.png)

我们来启动Elasticsearch

![image-20220622122545731](D:\Typora\File\nowcode_community\image-20220622122545731.png)

Elasticsearch的入门测试

![image-20220622123115036](D:\Typora\File\nowcode_community\image-20220622123115036.png)

当然我们也是可以使用postman来做的

![image-20220622123215364](D:\Typora\File\nowcode_community\image-20220622123215364.png)

### 第二节，Spring整合Elasticsearch

引入依赖 ： spring-boot-starter-data-elasticsearch 

第一步：导入包（pom.xml）

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch -->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>
```

第二步，配置Elasticsearch ：cluster-name、cluster-nodes （application.properties）

```properties
# ElasticsearchProperties
spring.data.elasticsearch.cluster-name=nowcoder
spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300
```

第三步，解决冲突问题，在启动类上面加上如下代码（CommunityApplication类）

```java
@PostConstruct
public void init() {
    // 解决netty启动冲突问题
    // see Netty4Utils.setAvailableProcessors()
    System.setProperty("es.set.netty.runtime.available.processors", "false");
}
```

第四步：将文章内容从数据库中复制一份到es中，便于数据的查询，具体可以使用以下两种方法：Spring Data Elasticsearch： ElasticsearchTemplate 、 ElasticsearchRepository。

具体实现如下：

①将DiscussPost类进行改造

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
//在 7.0 以及之后的版本中 Type 被废弃了。一个 index 中只有一个默认的 type，即 _doc。因此可以不写
@Document(indexName = "siscusspost",shards = 6,replicas = 3)
public class DiscussPost {

    //数据库的id
    @Id
    private int id;
    //用户的id
    @Field(type = FieldType.Integer)
    private int userId;
    //帖子的标题
    @Field(type = FieldType.Text,analyzer = "ik_max_word",searchAnalyzer = "ik_smart")
    private String title;
    //帖子的内容
    @Field(type = FieldType.Text,analyzer = "ik_max_word",searchAnalyzer = "ik_smart")
    private String content;
    //帖子的类型，1表示置顶
    @Field(type = FieldType.Integer)
    private int type;
    //帖子的状态，0表示正常，1表示精华，2表示拉黑
    @Field(type = FieldType.Integer)
    private int status;
    //帖子创建的日期
    @Field(type = FieldType.Date)
    private Date createTime;
    //帖子评论的数量
    @Field(type = FieldType.Integer)
    private int commentCount;
    //帖子的分数
    @Field(type = FieldType.Double)
    private double score;

}
```

②在dao包下面新建一个名为elasticsearch的包

```java
@Repository
//注意，这里不是mapper，mapper是mybatis的专有注解
//Repository是spring提供的dao层的注解
//这里不需要写任何的方法，我们只需要声明实体类的类型和主键的类型即可，es已经帮我们实现了这些方法的
//我们得到的数据也还是从mysql中取出来的数据，然后存入到es中
public interface DiscussPostRepository extends ElasticsearchRepository<DiscussPost, Integer> {

}
```

③下面来对es进行测试（ElasticsearchTests类）

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class ElasticsearchTests {

    @Autowired
    private DiscussPostMapper discussMapper;

    @Autowired
    private DiscussPostRepository discussRepository;

    @Autowired
    private RestHighLevelClient restHighLevelClient;


    /**
     * 一次性添加多条数据
     * 从数据库中取出帖子数据，然后插入到es中
     * 次执行的时候会插入一条数据
     */
    @Test
    public void testInsert() {
        discussRepository.save(discussMapper.selectDiscussPostById(241));
        discussRepository.save(discussMapper.selectDiscussPostById(242));
        discussRepository.save(discussMapper.selectDiscussPostById(243));
    }

    /**
     *
     * 一次性添加一条数据
     * 从数据库中取出帖子数据，然后插入到es中
     * 每次执行的时候会插入多条数据
     */

    @Test
    public void testInsertList() {
        discussRepository.saveAll(discussMapper.selectDiscussPosts(101, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(102, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(103, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(111, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(112, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(131, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(132, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(133, 0, 100));
        discussRepository.saveAll(discussMapper.selectDiscussPosts(134, 0, 100));
    }

    /**
     * 修改数据
     */
    @Test
    public void testUpdate() {
        DiscussPost post = discussMapper.selectDiscussPostById(231);
        post.setContent("我是新人,使劲灌水.");
        discussRepository.save(post);
    }

    /**
     *  删除数据
     *  一次删除一题
     *  一次删除索引数据
     */
    @Test
    public void testDelete() {
        //discussRepository.deleteById(231);
        discussRepository.deleteAll();
    }


    /**
     * 使用这样方法只会找到含有关键字的语句，
     * 但会不会有高亮显示
     */
    @Test
    public void noHighlightQuery() throws IOException {
        SearchRequest searchRequest = new SearchRequest("discusspost");//discusspost是索引名，就是表名

        //构建搜索条件
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()
                //在discusspost索引的title和content字段中都查询“互联网寒冬”
                .query(QueryBuilders.multiMatchQuery("互联网寒冬", "title", "content"))
                // matchQuery是模糊查询，会对key进行分词：searchSourceBuilder.query(QueryBuilders.matchQuery(key,value));
                // termQuery是精准查询：searchSourceBuilder.query(QueryBuilders.termQuery(key,value));
                .sort(SortBuilders.fieldSort("type").order(SortOrder.DESC))
                .sort(SortBuilders.fieldSort("score").order(SortOrder.DESC))
                .sort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
                //一个可选项，用于控制允许搜索的时间：searchSourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));
                .from(0)// 指定从哪条开始查询
                .size(10);// 需要查出的总记录条数

        searchRequest.source(searchSourceBuilder);
        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);

        System.out.println(JSONObject.toJSON(searchResponse));

        List<DiscussPost> list = new LinkedList<>();
        for (SearchHit hit : searchResponse.getHits().getHits()) {
            DiscussPost discussPost = JSONObject.parseObject(hit.getSourceAsString(), DiscussPost.class);
            System.out.println(discussPost);
            list.add(discussPost);
        }
    }

    /**
     * 使用这样方法只会找到含有关键字的语句，
     * 同时也会有高亮显示
     */
    @Test
    public void testSearchByTemplate() throws IOException {
        SearchRequest searchRequest = new SearchRequest("discusspost");

        //高亮
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field("title");
        highlightBuilder.field("content");
        highlightBuilder.requireFieldMatch(false);
        highlightBuilder.preTags("<em>");
        highlightBuilder.postTags("</em>");

        //构建搜索条件
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()
                .query(QueryBuilders.multiMatchQuery("互联网寒冬", "title", "content"))
                .sort(SortBuilders.fieldSort("type").order(SortOrder.DESC))
                .sort(SortBuilders.fieldSort("score").order(SortOrder.DESC))
                .sort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
                .from(0)
                .size(10)
                .highlighter(highlightBuilder);//高亮

        searchRequest.source(searchSourceBuilder);
        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);

        List<DiscussPost> list = new LinkedList<>();
        for (SearchHit hit : searchResponse.getHits().getHits()) {
            DiscussPost discussPost = JSONObject.parseObject(hit.getSourceAsString(), DiscussPost.class);

            // 处理高亮显示的结果
            HighlightField titleField = hit.getHighlightFields().get("title");
            if (titleField != null) {
                discussPost.setTitle(titleField.getFragments()[0].toString());
            }
            HighlightField contentField = hit.getHighlightFields().get("content");
            if (contentField != null) {
                discussPost.setContent(contentField.getFragments()[0].toString());
            }
            System.out.println(discussPost);
            list.add(discussPost);
        }
    }
}
```

### 第三节，开发社区搜索功能

- 搜索服务
  -  将帖子保存至Elasticsearch服务器。
  - 从Elasticsearch服务器删除帖子。
  - 从Elasticsearch服务器搜索帖子。
- 发布事件
  - 发布帖子时，将帖子异步的提交到Elasticsearch服务器。
  - 增加评论时，将帖子异步的提交到Elasticsearch服务器。 
  - 在消费组件中增加一个方法，消费帖子发布事件。 
- 显示结果
  - 在控制器中处理搜索请求，在HTML上显示搜索结果。

第一步：编写service层（ElasticsearchService类）

```java
@Service
public class ElasticsearchService {

    @Autowired
    private DiscussPostRepository discussRepository;

    @Autowired
    private RestHighLevelClient restHighLevelClient;

    public void saveDiscussPost(DiscussPost post) {
        discussRepository.save(post);
    }

    public void deleteDiscussPost(int id) {
        discussRepository.deleteById(id);
    }

    public Page<DiscussPost> searchDiscussPost(String keyword, int current, int limit) throws IOException {
        SearchRequest searchRequest = new SearchRequest("discusspost");

        //高亮
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field("title");
        highlightBuilder.field("content");
        highlightBuilder.requireFieldMatch(false);
        highlightBuilder.preTags("<em>");
        highlightBuilder.postTags("</em>");

        //构建搜索条件
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()
                .query(QueryBuilders.multiMatchQuery(keyword, "title", "content"))
                .sort(SortBuilders.fieldSort("type").order(SortOrder.DESC))
                .sort(SortBuilders.fieldSort("score").order(SortOrder.DESC))
                .sort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
                .from(current)
                .size(limit)
                .highlighter(highlightBuilder);//高亮

        searchRequest.source(searchSourceBuilder);
        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);

        List<DiscussPost> list = new LinkedList<>();
        for (SearchHit hit : searchResponse.getHits().getHits()) {
            DiscussPost discussPost = JSONObject.parseObject(hit.getSourceAsString(), DiscussPost.class);

            // 处理高亮显示的结果
            HighlightField titleField = hit.getHighlightFields().get("title");
            if (titleField != null) {
                discussPost.setTitle(titleField.getFragments()[0].toString());
            }
            HighlightField contentField = hit.getHighlightFields().get("content");
            if (contentField != null) {
                discussPost.setContent(contentField.getFragments()[0].toString());
            }
            //System.out.println(discussPost);
            list.add(discussPost);
        }
        return new PageImpl<>(list);
    }
}
```

第二步：在发布的帖子和评论中加入到es服务器中，便于查询

DiscussPostController类中的addDiscussPost方法中加入下列代码：

```java
// 触发发帖事件
Event event = new Event()
        .setTopic(TOPIC_PUBLISH)
        .setUserId(user.getId())
        .setEntityType(ENTITY_TYPE_POST)
        .setEntityId(post.getId());
eventProducer.fireEvent(event);
```

CommentController类中的addComment方法中加入下列代码：

```java
if (comment.getEntityType() == ENTITY_TYPE_POST) {
    // 触发发帖事件
    event = new Event()
            .setTopic(TOPIC_PUBLISH)
            .setUserId(comment.getUserId())
            .setEntityType(ENTITY_TYPE_POST)
            .setEntityId(discussPostId);
    eventProducer.fireEvent(event);
}
```

第三步：EventConsumer类中加入下列代码：

```java
// 消费发帖事件
@KafkaListener(topics = {TOPIC_PUBLISH})
public void handlePublishMessage(ConsumerRecord record) {
    if (record == null || record.value() == null) {
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(), Event.class);
    if (event == null) {
        logger.error("消息格式错误!");
        return;
    }

    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());
    elasticsearchService.saveDiscussPost(post);
}
```

第四步：编写controller层（SearchController类）

```java
@Controller
public class SearchController implements CommunityConstant {

    @Autowired
    private ElasticsearchService elasticsearchService;

    @Autowired
    private UserService userService;

    @Autowired
    private LikeService likeService;

    // search?keyword=xxx
    @RequestMapping(path = "/search", method = RequestMethod.GET)
    public String search(String keyword, Page page, Model model) throws IOException {
        // 搜索帖子
        org.springframework.data.domain.Page<DiscussPost> searchResult =
                elasticsearchService.searchDiscussPost(keyword, page.getCurrent() - 1, page.getLimit());
        // 聚合数据
        List<Map<String, Object>> discussPosts = new ArrayList<>();
        if (searchResult != null) {
            for (DiscussPost post : searchResult) {
                Map<String, Object> map = new HashMap<>();
                // 帖子
                map.put("post", post);
                // 作者
                map.put("user", userService.findUserById(post.getUserId()));
                // 点赞数量
                map.put("likeCount", likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId()));

                discussPosts.add(map);
            }
        }
        model.addAttribute("discussPosts", discussPosts);
        model.addAttribute("keyword", keyword);

        // 分页信息
        page.setPath("/search?keyword=" + keyword);
        page.setRows(searchResult == null ? 0 : (int) searchResult.getTotalElements());

        return "/site/search";
    }

}
```

第五步：前端页面的处理：

![image-20220625172158134](D:\Typora\File\nowcode_community\image-20220625172158134.png)

![image-20220625172509609](D:\Typora\File\nowcode_community\image-20220625172509609.png)

## 第7章 项目进阶，构建安全高效的企业服务

### 第一节，Spring Security

参考网站：https://spring.io/projects/spring-security

简介 ：Spring Security是spring为安全所作的框架，是一个专注于为Java应用程序提供 身份认证和授权的框架，它的强大之处在于它可以 轻松扩展以满足自定义的需求。

特征 

- 对身份的 **认证**（是否已登陆） 和 **授权**（是否有做相应操作的权限） 提供全面的、可扩展的支持。
- 防止各种攻击，如会话固定攻击、点击劫持、csrf攻击等。
- 支持与Servlet API、Spring MVC等Web技术集成

![image-20220625172733359](D:\Typora\File\nowcode_community\image-20220625172733359.png)



### 第二节，权限控制

- 登录检查 :  之前采用拦截器实现了登录检查，这是简单的权限管理方案，现在将其废弃。 

- 授权配置  : 对当前系统内包含的所有的请求，分配访问权限（普通用户、版主、管理员）。

- 认证方案 : 绕过Security认证流程，采用系统原来的认证方案。

- CSRF配置 :  防止 CSRF 攻击的基本原理，以及表单、AJAX相关的配置。


第一步：导入依赖

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-security -->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

第二步：添加常量，便于后期的权限管理的相关应用：（CommunityConstant类）

```java
/**
 * 权限: 普通用户
 */
String AUTHORITY_USER = "user";

/**
 * 权限: 管理员
 */
String AUTHORITY_ADMIN = "admin";

/**
 * 权限: 版主
 */
String AUTHORITY_MODERATOR = "moderator";
```

第三步：编写配置类（SecurityConfig类）

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter implements CommunityConstant {

    /**
     * 忽略掉对静态资源的拦截
     * @param web
     * @throws Exception
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/resources/**");
    }

    /**
     * 进行授权
     * 对所有的controller中的路径进行授权
     * @param http http请求
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 对下面出现的路径进行授权，只要石下面的路径都是可以访问的
        //这些路径都是登录以后就可以访问的，不论登陆以后是什么权限，都是可以来访问的
        http.authorizeRequests()
                .antMatchers(
                        "/user/setting",
                        "/user/upload",
                        "/discuss/add",
                        "/comment/add/**",
                        "/letter/**",
                        "/notice/**",
                        "/like",
                        "/follow",
                        "/unfollow"
                )
                //这些路径都是登录以后就可以访问的，不论登陆以后是什么权限，都是可以来访问的
                .hasAnyAuthority(
                        AUTHORITY_USER,
                        AUTHORITY_ADMIN,
                        AUTHORITY_MODERATOR
                )
                //除了上述的路径以外的其他路径都是可以直接访问的,就有说即使不登陆也是可以来访问的
                .anyRequest().permitAll()
            	//禁用csrf
                .and().csrf().disable();

        // 权限不够时的处理
        http.exceptionHandling()
                // 没有登录
                .authenticationEntryPoint((request, response, e) -> {
                    String xRequestedWith = request.getHeader("x-requested-with");
                    if ("XMLHttpRequest".equals(xRequestedWith)) {
                        response.setContentType("application/plain;charset=utf-8");
                        PrintWriter writer = response.getWriter();
                        writer.write(CommunityUtil.getJSONString(403, "你还没有登录哦!"));
                    } else {
                        response.sendRedirect(request.getContextPath() + "/login");
                    }
                })
                // 权限不足
                .accessDeniedHandler((request, response, e) -> {
                    String xRequestedWith = request.getHeader("x-requested-with");
                    if ("XMLHttpRequest".equals(xRequestedWith)) {
                        response.setContentType("application/plain;charset=utf-8");
                        PrintWriter writer = response.getWriter();
                        writer.write(CommunityUtil.getJSONString(403, "你没有访问此功能的权限!"));
                    } else {
                        response.sendRedirect(request.getContextPath() + "/denied");
                    }
                });

        // Security底层默认会拦截/logout请求,进行退出处理.
        // 覆盖它默认的逻辑,才能执行我们自己的退出代码.
        http.logout().logoutUrl("/securitylogout");
    }

}
```

第四步：在UserController中加入以下的代码，用于在登陆以后没有权限的时候会出现404的页面

```java
/**
     * 拒接访问的时候的提示页面
     * 当没有权限访问的时候就直接跳转到错误页面
     * @return
     */
@RequestMapping(path = "/denied",method = RequestMethod.GET)
public String getDeniedPage(){
    return "/error/404";
}
```

第五步：在UserService中加入如下的代码，用来查询当前登录用户的权限

```java
/**
     * 查询该用户的权限
     * @param userId 用户的id
     * @return
     */
public Collection<? extends GrantedAuthority> getAuthorities(int userId) {
    User user = this.findUserById(userId);

    //将判断权限的结果存入到一个集合中
    List<GrantedAuthority> list = new ArrayList<>();
    list.add((GrantedAuthority) () -> {
        switch (user.getType()) {
            case 1:
                //1表示管理员
                return AUTHORITY_ADMIN;
            case 2:
                //2表示版主
                return AUTHORITY_MODERATOR;
            default:
                //默认表示普通用户
                return AUTHORITY_USER;
        }
    });
    return list;
}
```

第六步：在LoginTicketInterceptor类中的preHandle方法中加入以下的内容

```java
// 构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.
Authentication authentication = new UsernamePasswordAuthenticationToken(
        user, user.getPassword(), userService.getAuthorities(user.getId()));
SecurityContextHolder.setContext(new SecurityContextImpl(authentication));
```

在afterCompletion方法中加入如下的代码：

```java
//表示在退出的时候就将这个token中的认证的权限清除掉
SecurityContextHolder.clearContext();
```

在Loginontroller中的logout方法上面也是需要将这个认证的权限给清除掉

```java
SecurityContextHolder.clearContext();
```

注意：

1. Security提供了认证和授权两个功能，我们在DEMO里也做了演示，而在项目中应用时，我们并没有使用它的 认证功能，而单独的使用了它的授权功能，所以需要对认证的环节做一下特殊的处理，以保证授权的正常进行；
2.  Security的所有功能，都是基于Filter实现的，而Filter的执行早于Interceptor和Controller，关于Security的拦截器原理，可以参考http://www.spring4all.com/article/458；
3.  我们的解决方案是，在Interceptor中判断登录与否，然后人为的将认证结果添加到了SecurityContextHolder里。这里要注意，由于Interceptor执行晚于Filter，所以认证的进行依赖于前一次请求的拦截器处理。比如，我登录成功了，然后请求自行重定向到了首页。在访问首页时，认证Filter其实没起作用，因为这个请求不需要权限，然后执行了Interceptor，此时才将认证结果加入SecurityContextHolder，这时你再访问/letter/list，可以成功，因为在这次请求里，Filter根据刚才的认证结果，判断出来你有了权限；
4. 退出时，需要将SecurityContextHolder里面的认证结果清理掉，这样下次请求时，Filter才能正确识别用户的权限；
5.  LoginTicketInterceptor中的afterCompletion中其实不用清理SecurityContextHolder，将这句话删掉。

### 第三节，置顶、加精、删除

- 功能实现
  - 点击 置顶，修改帖子的类型。
  - 点击“加精”、“删除”，修改帖子的状态。
- 权限管理 
  - 版主可以执行“置顶”、“加精”操作。
  - 管理员可以执行“删除”操作。
- 按钮显示 
  - 版主可以看到“置顶”、“加精”按钮。
  - 管理员可以看到“删除”按钮。

由于这几个功能是相似的，因此我们可以一起做开发，后面还是会涉及到取消置顶和取消加精的操作

第一步：编写数据访问层：

DiscussPostMapper接口：

```java
/**
 * 修改帖子的类型，用于置顶操作
 * @param id 帖子的id
 * @param type 帖子的类型
 * @return
 */
int updateType(int id, int type);

/**
 * 修改帖子的状态，用于加精操作
 * @param id 帖子的id
 * @param status 帖子的状态
 * @return
 */
int updateStatus(int id, int status);
```

Mapper文件（discusspost-mapper.xml）

```xml
<!--修改帖子的类型，用于置顶操作-->
<!--int updateType(int id, int type);-->
<update id="updateType">
    update discuss_post set type = #{type} where id = #{id}
</update>

<!--修改帖子的状态，用于加精操作-->
<!--int updateStatus(int id, int status);-->
<update id="updateStatus">
    update discuss_post set status = #{status} where id = #{id}
</update>
```

第二步：编写service层：（DiscussPostService类）

```java
/**
 * 修改帖子的类型，用于置顶操作
 * @param id 帖子的id
 * @param type 帖子的类型
 * @return
 */
public int updateType(int id, int type) {
    return discussPostMapper.updateType(id, type);
}

/**
 * 修改帖子的状态，用于加精操作
 * @param id 帖子的id
 * @param status 帖子的状态
 * @return
 */
public int updateStatus(int id, int status) {
    return discussPostMapper.updateStatus(id, status);
}
```

第三步：编写删帖事件，就是将帖子从es中删除掉（EventConsumer类）

```java
// 消费删帖事件
@KafkaListener(topics = {TOPIC_DELETE})
public void handleDeleteMessage(ConsumerRecord record) {
    if (record == null || record.value() == null) {
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(), Event.class);
    if (event == null) {
        logger.error("消息格式错误!");
        return;
    }

    elasticsearchService.deleteDiscussPost(event.getEntityId());
}
```

第四步：编写controller层：（DiscussPostController类）

```java
/**
 * 置顶
 * @param id 帖子的id
 * @return
 */
@RequestMapping(path = "/top", method = RequestMethod.POST)
//由于要使用异步请求，因此就需要加上@ResponseBody注解
@ResponseBody
public String setTop(int id) {
    discussPostService.updateType(id, 1);

    // 触发发帖事件
    Event event = new Event()
            .setTopic(TOPIC_PUBLISH)
            .setUserId(hostHolder.getUser().getId())
            .setEntityType(ENTITY_TYPE_POST)
            .setEntityId(id);
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);
}

/**
 * 加精
 * @param id 帖子的id
 * @return
 */
@RequestMapping(path = "/wonderful", method = RequestMethod.POST)
@ResponseBody
public String setWonderful(int id) {
    discussPostService.updateStatus(id, 1);

    // 触发发帖事件
    Event event = new Event()
            .setTopic(TOPIC_PUBLISH)
            .setUserId(hostHolder.getUser().getId())
            .setEntityType(ENTITY_TYPE_POST)
            .setEntityId(id);
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);
}

/**
 * 删除
 * @param id 帖子的id
 * @return
 */
@RequestMapping(path = "/delete", method = RequestMethod.POST)
@ResponseBody
public String setDelete(int id) {
    discussPostService.updateStatus(id, 2);

    // 触发删帖事件
    Event event = new Event()
            .setTopic(TOPIC_DELETE)
            .setUserId(hostHolder.getUser().getId())
            .setEntityType(ENTITY_TYPE_POST)
            .setEntityId(id);
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);
}
```

第五步，前端页面：

我们先要编写者三个功能的js（discuss.js）

```js
$(function (){
   $("#topBtn").click(setTop);
   $("#wonderfulBtn").click(setWonderful);
   $("#deleteBtn").click(setDelete);
});

// 置顶
function setTop() {
    $.post(
        CONTEXT_PATH + "/discuss/top",
        {"id":$("#postId").val()},
        function(data) {
            data = $.parseJSON(data);
            if(data.code == 0) {
                $("#topBtn").attr("disabled", "disabled");
            } else {
                alert(data.msg);
            }
        }
    );
}

// 加精
function setWonderful() {
    $.post(
        CONTEXT_PATH + "/discuss/wonderful",
        {"id":$("#postId").val()},
        function(data) {
            data = $.parseJSON(data);
            if(data.code == 0) {
                $("#wonderfulBtn").attr("disabled", "disabled");
            } else {
                alert(data.msg);
            }
        }
    );
}

// 删除
function setDelete() {
    $.post(
        CONTEXT_PATH + "/discuss/delete",
        {"id":$("#postId").val()},
        function(data) {
            data = $.parseJSON(data);
            if(data.code == 0) {
                location.href = CONTEXT_PATH + "/index";
            } else {
                alert(data.msg);
            }
        }
    );
}
```

![image-20220626221230049](D:\Typora\File\nowcode_community\image-20220626221230049.png)

第六步：这三个功能是与权限有关的，因此我们需要在权限里面做一些配置（SecurityConfig类）

```java
 .antMatchers(
                        "/discuss/top",
                        "/discuss/wonderful"
                )
                .hasAnyAuthority(
                        AUTHORITY_MODERATOR
                )
                .antMatchers(
                        "/discuss/delete"
                )
                .hasAnyAuthority(
                        AUTHORITY_ADMIN
                )
```

前端页面的处理：

![image-20220626222611599](D:\Typora\File\nowcode_community\image-20220626222611599.png)

现在我们来测试的时候就会发现没有登录的时候或者是普通用户的时候，任何功能都是看不见的，版主和管理员都是由自己特点的权限

下面来做取消置顶和取消加精的功能：

前端页面

![image-20220626224013084](D:\Typora\File\nowcode_community\image-20220626224013084.png)

js文件

```js
//置顶
function setTop() {
    $.post(
        CONTEXT_PATH + "/discuss/top/"+$("#topBtn").val(),
        {"id":$("#postId").val()},
        function (data) {
            data = $.parseJSON(data);
            if(data.code == 0) {
                location.reload();//刷新页面
            } else {
                alert(data.msg);
            }
        }
    );
}

//加精
function setWonderful() {
    $.post(
        CONTEXT_PATH + "/discuss/wonderful/"+$("#wonderfulBtn").val(),
        {"id":$("#postId").val()},
        function (data) {
            data = $.parseJSON(data);
            if(data.code == 0) {
                location.reload();//刷新页面
            } else {
                alert(data.msg);
            }
        }
    );
}
```

controller层：

```java
/**
 * 置顶
 * @param id 帖子的id
 * @return
 */
//置顶请求
@RequestMapping(path = "/top/{type}", method = RequestMethod.POST)
@ResponseBody//异步请求
public String setTop(int id, @PathVariable("type") int type) {
    if (type == 0) {//如果收到type为0，表示本来是普通帖子，然后现在接收到你的置顶请求，所以我们要把type设置为1然后传到updatType中
        type = 1;
    } else {
        type = 0;
    }
    discussPostService.updateType(id,type);
    //触发发帖事件，同步到ES中
    Event event = new Event()
            .setTopic(TOPIC_PUBLISH)
            .setUserId(hostHolder.getUser().getId())
            .setEntityType(ENTITY_TYPE_POST)
            .setEntityId(id);
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);
}

/**
 * 加精
 * @param id 帖子的id
 * @return
 */
//加精请求
@RequestMapping(path = "/wonderful/{status}", method = RequestMethod.POST)
@ResponseBody//异步请求
public String setWonderful(int id,@PathVariable("status") int status) {
    if (status == 0) {
        status = 1;
    } else {
        status = 0;
    }
    discussPostService.updateStatus(id,status);
    //触发发帖事件，同步到ES中
    Event event = new Event()
            .setTopic(TOPIC_PUBLISH)
            .setUserId(hostHolder.getUser().getId())
            .setEntityType(ENTITY_TYPE_POST)
            .setEntityId(id);
    eventProducer.fireEvent(event);

    return CommunityUtil.getJSONString(0);
}
```

### 第四节，Redis高级数据类型

- HyperLogLog 
  - 采用一种基数算法，用于完成独立总数的统计。
  - 占据空间小，无论统计多少个数据，只占12K的内存空间。
  - 不精确的统计算法，标准误差为 0.81% 。
- Bitmap
  - 不是一种独立的数据结构，实际上就是字符串。
  - 支持按位存取数据，可以将其看成是byte数组。
  - 适合存储索大量的连续的数据的布尔值。

在本节中，我们对这两种数据结构做一个测试：（RedisTests类）

```java
// 统计20万个重复数据的独立总数.
@Test
public void testHyperLogLog() {
    String redisKey = "test:hll:01";

    for (int i = 1; i <= 100000; i++) {
        redisTemplate.opsForHyperLogLog().add(redisKey, i);
    }

    for (int i = 1; i <= 100000; i++) {
        int r = (int) (Math.random() * 100000 + 1);
        redisTemplate.opsForHyperLogLog().add(redisKey, r);
    }

    long size = redisTemplate.opsForHyperLogLog().size(redisKey);
    System.out.println(size);
}

// 将3组数据合并, 再统计合并后的重复数据的独立总数.
@Test
public void testHyperLogLogUnion() {
    String redisKey2 = "test:hll:02";
    for (int i = 1; i <= 10000; i++) {
        redisTemplate.opsForHyperLogLog().add(redisKey2, i);
    }

    String redisKey3 = "test:hll:03";
    for (int i = 5001; i <= 15000; i++) {
        redisTemplate.opsForHyperLogLog().add(redisKey3, i);
    }

    String redisKey4 = "test:hll:04";
    for (int i = 10001; i <= 20000; i++) {
        redisTemplate.opsForHyperLogLog().add(redisKey4, i);
    }

    String unionKey = "test:hll:union";
    redisTemplate.opsForHyperLogLog().union(unionKey, redisKey2, redisKey3, redisKey4);

    long size = redisTemplate.opsForHyperLogLog().size(unionKey);
    System.out.println(size);
}

// 统计一组数据的布尔值
@Test
public void testBitMap() {
    String redisKey = "test:bm:01";

    // 记录
    redisTemplate.opsForValue().setBit(redisKey, 1, true);
    redisTemplate.opsForValue().setBit(redisKey, 4, true);
    redisTemplate.opsForValue().setBit(redisKey, 7, true);

    // 查询
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 0));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 1));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 2));

    // 统计
    Object obj = redisTemplate.execute(new RedisCallback() {
        @Override
        public Object doInRedis(RedisConnection connection) throws DataAccessException {
            return connection.bitCount(redisKey.getBytes());
        }
    });

    System.out.println(obj);
}

// 统计3组数据的布尔值, 并对这3组数据做OR运算.
@Test
public void testBitMapOperation() {
    String redisKey2 = "test:bm:02";
    redisTemplate.opsForValue().setBit(redisKey2, 0, true);
    redisTemplate.opsForValue().setBit(redisKey2, 1, true);
    redisTemplate.opsForValue().setBit(redisKey2, 2, true);

    String redisKey3 = "test:bm:03";
    redisTemplate.opsForValue().setBit(redisKey3, 2, true);
    redisTemplate.opsForValue().setBit(redisKey3, 3, true);
    redisTemplate.opsForValue().setBit(redisKey3, 4, true);

    String redisKey4 = "test:bm:04";
    redisTemplate.opsForValue().setBit(redisKey4, 4, true);
    redisTemplate.opsForValue().setBit(redisKey4, 5, true);
    redisTemplate.opsForValue().setBit(redisKey4, 6, true);

    String redisKey = "test:bm:or";
    Object obj = redisTemplate.execute(new RedisCallback() {
        @Override
        public Object doInRedis(RedisConnection connection) throws DataAccessException {
            connection.bitOp(RedisStringCommands.BitOperation.OR,
                    redisKey.getBytes(), redisKey2.getBytes(), redisKey3.getBytes(), redisKey4.getBytes());
            return connection.bitCount(redisKey.getBytes());
        }
    });

    System.out.println(obj);

    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 0));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 1));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 2));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 3));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 4));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 5));
    System.out.println(redisTemplate.opsForValue().getBit(redisKey, 6));
}
```

### 第五节，网站数据统计

- UV（Unique Visitor）
  - 独立访客，需通过用户 IP 排重统计数据。
  - 每次访问都要进行统计。
  - HyperLogLog ，性能好，且存储空间小。
- DAU（Daily Active User）
  - 日活跃用户，需通过用户 ID 排重统计数据。
  - 访问过一次，则认为其活跃。
  - Bitmap，性能好、且可以统计精确的结果。

第一步：编写Redis工具类（RedisKeyUtil类）

```java
private static final String PREFIX_UV = "uv";
private static final String PREFIX_DAU = "dau";

// 单日UV
public static String getUVKey(String date) {
return PREFIX_UV + SPLIT + date;
}
// 区间UV
public static String getUVKey(String startDate, String endDate) {
return PREFIX_UV + SPLIT + startDate + SPLIT + endDate;
}

// 单日活跃用户
public static String getDAUKey(String date) {
return PREFIX_DAU + SPLIT + date;
}

// 区间活跃用户
public static String getDAUKey(String startDate, String endDate) {
return PREFIX_DAU + SPLIT + startDate + SPLIT + endDate;
}
```

第二步：编写service层的方法：

```java
@Service
public class DataService {

    @Autowired
    private RedisTemplate redisTemplate;

    private SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");

    // 将指定的IP计入UV
    public void recordUV(String ip) {
        String redisKey = RedisKeyUtil.getUVKey(df.format(new Date()));
        redisTemplate.opsForHyperLogLog().add(redisKey, ip);
    }

    // 统计指定日期范围内的UV
    public long calculateUV(Date start, Date end) {
        if (start == null || end == null) {
            throw new IllegalArgumentException("参数不能为空!");
        }

        // 整理该日期范围内的key
        List<String> keyList = new ArrayList<>();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(start);
        while (!calendar.getTime().after(end)) {
            String key = RedisKeyUtil.getUVKey(df.format(calendar.getTime()));
            keyList.add(key);
            calendar.add(Calendar.DATE, 1);
        }

        // 合并这些数据
        String redisKey = RedisKeyUtil.getUVKey(df.format(start), df.format(end));
        redisTemplate.opsForHyperLogLog().union(redisKey, keyList.toArray());

        // 返回统计的结果
        return redisTemplate.opsForHyperLogLog().size(redisKey);
    }

    // 将指定用户计入DAU
    public void recordDAU(int userId) {
        String redisKey = RedisKeyUtil.getDAUKey(df.format(new Date()));
        redisTemplate.opsForValue().setBit(redisKey, userId, true);
    }

    // 统计指定日期范围内的DAU
    public long calculateDAU(Date start, Date end) {
        if (start == null || end == null) {
            throw new IllegalArgumentException("参数不能为空!");
        }

        // 整理该日期范围内的key
        List<byte[]> keyList = new ArrayList<>();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(start);
        while (!calendar.getTime().after(end)) {
            String key = RedisKeyUtil.getDAUKey(df.format(calendar.getTime()));
            keyList.add(key.getBytes());
            calendar.add(Calendar.DATE, 1);
        }

        // 进行OR运算
        return (long) redisTemplate.execute(new RedisCallback() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                String redisKey = RedisKeyUtil.getDAUKey(df.format(start), df.format(end));
                connection.bitOp(RedisStringCommands.BitOperation.OR,
                        redisKey.getBytes(), keyList.toArray(new byte[0][0]));
                return connection.bitCount(redisKey.getBytes());
            }
        });
    }

}
```

第三步：配置拦截器和拦截路径（DataInterceptor类）

```java
@Component
public class DataInterceptor implements HandlerInterceptor {

    @Autowired
    private DataService dataService;

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 统计UV
        String ip = request.getRemoteHost();
        dataService.recordUV(ip);

        // 统计DAU
        User user = hostHolder.getUser();
        if (user != null) {
            dataService.recordDAU(user.getId());
        }

        return true;
    }
}
```

WebMvcConfig类

```java
@Autowired
private DataInterceptor dataInterceptor;
registry.addInterceptor(dataInterceptor)
.excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
}
```

第四步：编写controller层的方法：

```java
@Controller
public class DataController {

    @Autowired
    private DataService dataService;

    // 统计页面
    @RequestMapping(path = "/data", method = {RequestMethod.GET, RequestMethod.POST})
    public String getDataPage() {
        return "/site/admin/data";
    }

    // 统计网站UV
    @RequestMapping(path = "/data/uv", method = RequestMethod.POST)
    public String getUV(@DateTimeFormat(pattern = "yyyy-MM-dd") Date start,
                        @DateTimeFormat(pattern = "yyyy-MM-dd") Date end, Model model) {
        long uv = dataService.calculateUV(start, end);
        model.addAttribute("uvResult", uv);
        model.addAttribute("uvStartDate", start);
        model.addAttribute("uvEndDate", end);
        return "forward:/data";
    }

    // 统计活跃用户
    @RequestMapping(path = "/data/dau", method = RequestMethod.POST)
    public String getDAU(@DateTimeFormat(pattern = "yyyy-MM-dd") Date start,
                         @DateTimeFormat(pattern = "yyyy-MM-dd") Date end, Model model) {
        long dau = dataService.calculateDAU(start, end);
        model.addAttribute("dauResult", dau);
        model.addAttribute("dauStartDate", start);
        model.addAttribute("dauEndDate", end);
        return "forward:/data";
    }
}
```

前端页面：

![image-20220627093650389](D:\Typora\File\nowcode_community\image-20220627093650389.png)

最后再配置一下权限控制即可。

最后的展示结果不知道为什么没有报错，但是也是没有结果的显示

![image-20220627093855621](D:\Typora\File\nowcode_community\image-20220627093855621.png)

### 第六节，任务执行和调度

参考网站：http://www.quartz-scheduler.org

- JDK 线程池
  - ExcecutorService
  -  ScheduledExecutorService
- Spring 线程池 
  - ThreadPoolTaskExecutor 
  - ThreadPoolTaskScheduler
- 分布式定时任务
  - Spring Quartz

![image-20220627102315267](D:\Typora\File\nowcode_community\image-20220627102315267.png)

配置文件的编写：（application.properties）

```properties
# TaskExecutionProperties
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=15
spring.task.execution.pool.queue-capacity=100

# TaskSchedulingProperties
spring.task.scheduling.pool.size=5

# QuartzProperties
spring.quartz.job-store-type=jdbc
spring.quartz.scheduler-name=communityScheduler
spring.quartz.properties.org.quartz.scheduler.instanceId=AUTO
spring.quartz.properties.org.quartz.jobStore.class=org.springframework.scheduling.quartz.LocalDataSourceJobStore
spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
spring.quartz.properties.org.quartz.jobStore.isClustered=true
spring.quartz.properties.org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool
spring.quartz.properties.org.quartz.threadPool.threadCount=5
```

测试类的编写：

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class ThreadPoolTests {

    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolTests.class);

    // JDK普通线程池
    private ExecutorService executorService = Executors.newFixedThreadPool(5);

    // JDK可执行定时任务的线程池
    private ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);

    // Spring普通线程池
    @Autowired
    private ThreadPoolTaskExecutor taskExecutor;

    // Spring可执行定时任务的线程池
    @Autowired
    private ThreadPoolTaskScheduler taskScheduler;

    @Autowired
    private AlphaService alphaService;

    private void sleep(long m) {
        try {
            Thread.sleep(m);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 1.JDK普通线程池
    @Test
    public void testExecutorService() {
        Runnable task = () -> logger.debug("Hello ExecutorService");

        for (int i = 0; i < 10; i++) {
            executorService.submit(task);
        }

        sleep(10000);
    }

    // 2.JDK定时任务线程池
    @Test
    public void testScheduledExecutorService() {
        Runnable task = () -> logger.debug("Hello ScheduledExecutorService");

        scheduledExecutorService.scheduleAtFixedRate(task, 10000, 1000, TimeUnit.MILLISECONDS);

        sleep(30000);
    }

    // 3.Spring普通线程池
    @Test
    public void testThreadPoolTaskExecutor() {
        Runnable task = () -> logger.debug("Hello ThreadPoolTaskExecutor");

        for (int i = 0; i < 10; i++) {
            taskExecutor.submit(task);
        }

        sleep(10000);
    }

    // 4.Spring定时任务线程池
    @Test
    public void testThreadPoolTaskScheduler() {
        Runnable task = () -> logger.debug("Hello ThreadPoolTaskScheduler");

        Date startTime = new Date(System.currentTimeMillis() + 10000);
        taskScheduler.scheduleAtFixedRate(task, startTime, 1000);

        sleep(30000);
    }

    // 5.Spring普通线程池(简化)
    @Test
    public void testThreadPoolTaskExecutorSimple() {
        for (int i = 0; i < 10; i++) {
            alphaService.execute1();
        }

        sleep(10000);
    }

    // 6.Spring定时任务线程池(简化)
    @Test
    public void testThreadPoolTaskSchedulerSimple() {
        sleep(30000);
    }
}
```

下面是Quartz的演示：

先编写一个任务调度（AlphaJob）

```java
public class AlphaJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        System.out.println(Thread.currentThread().getName() + ": execute a quartz job.");
    }
}
```

然后编写配置类：（QuartzConfig）

```java
@Configuration
public class QuartzConfig {

    // FactoryBean可简化Bean的实例化过程:
    // 1.通过FactoryBean封装Bean的实例化过程.
    // 2.将FactoryBean装配到Spring容器里.
    // 3.将FactoryBean注入给其他的Bean.
    // 4.该Bean得到的是FactoryBean所管理的对象实例.

    // 配置JobDetail
    @Bean
    public JobDetailFactoryBean alphaJobDetail() {
        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
        factoryBean.setJobClass(AlphaJob.class);
        factoryBean.setName("alphaJob");
        factoryBean.setGroup("alphaJobGroup");
        factoryBean.setDurability(true);
        factoryBean.setRequestsRecovery(true);
        return factoryBean;
    }

    // 配置Trigger(SimpleTriggerFactoryBean, CronTriggerFactoryBean)
    @Bean
    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail) {
        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
        factoryBean.setJobDetail(alphaJobDetail);
        factoryBean.setName("alphaTrigger");
        factoryBean.setGroup("alphaTriggerGroup");
        factoryBean.setRepeatInterval(3000);
        factoryBean.setJobDataMap(new JobDataMap());
        return factoryBean;
    }

}
```

![image-20220627105122280](D:\Typora\File\nowcode_community\image-20220627105122280.png)

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class QuartzTests {

    @Autowired
    private Scheduler scheduler;

    @Test
    public void testDeleteJob() {
        try {
            boolean result = scheduler.deleteJob(new JobKey("alphaJob", "alphaJobGroup"));
            System.out.println(result);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

}
```

### 第七节，热帖排行

帖子的热度：log(精华分 + 评论数*10 + 点赞数*2 + 收藏数*2) + (发布时间 - 牛客纪元)

第一步：编写redis工具类：（RedisKeyUtil类）

```java
private static final String PREFIX_POST = "post";
// 帖子分数
public static String getPostScoreKey() {
    return PREFIX_POST + SPLIT + "score";
}
```

第二步：编写更新分数的dao层的service层

dao层的Java（DiscussPostMapper接口）

```java
/**
 * 修改帖子的分数，便于最热帖子的排行
 * @param id 帖子的id
 * @param score 分数
 * @return
 */
int updateScore(int id, double score);
```

dao层的Mapper（discusspost-mapper.xml）

```xml
<!--修改帖子的分数，便于最热帖子的排行-->
<!--int updateScore(int id, double score);-->
<update id="updateScore">
    update discuss_post set score = #{score} where id = #{id}
</update>
```

service层：（DiscussPostService类）

```java
/**
 * 修改帖子的分数，便于最热帖子的排行
 * @param id 帖子的id
 * @param score 分数
 * @return
 */
public int updateScore(int id, double score) {
    return discussPostMapper.updateScore(id, score);
}
```

第三步：编写任务（PostScoreRefreshJob类）

```java
public class PostScoreRefreshJob implements Job, CommunityConstant {

    private static final Logger logger = LoggerFactory.getLogger(PostScoreRefreshJob.class);

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private ElasticsearchService elasticsearchService;

    // 牛客纪元
    private static final Date epoch;

    static {
        try {
            epoch = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2014-08-01 00:00:00");
        } catch (ParseException e) {
            throw new RuntimeException("初始化牛客纪元失败!", e);
        }
    }

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        String redisKey = RedisKeyUtil.getPostScoreKey();
        BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);

        if (operations.size() == 0) {
            logger.info("[任务取消] 没有需要刷新的帖子!");
            return;
        }

        logger.info("[任务开始] 正在刷新帖子分数: " + operations.size());
        while (operations.size() > 0) {
            this.refresh((Integer) operations.pop());
        }
        logger.info("[任务结束] 帖子分数刷新完毕!");
    }

    private void refresh(int postId) {
        DiscussPost post = discussPostService.findDiscussPostById(postId);

        if (post == null) {
            logger.error("该帖子不存在: id = " + postId);
            return;
        }

        // 是否精华
        boolean wonderful = post.getStatus() == 1;
        // 评论数量
        int commentCount = post.getCommentCount();
        // 点赞数量
        long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);

        // 计算权重
        double w = (wonderful ? 75 : 0) + commentCount * 10 + likeCount * 2;
        // 分数 = 帖子权重 + 距离天数
        double score = Math.log10(Math.max(w, 1))
                + (post.getCreateTime().getTime() - epoch.getTime()) / (1000 * 3600 * 24);
        // 更新帖子分数
        discussPostService.updateScore(postId, score);
        // 同步搜索数据
        post.setScore(score);
        elasticsearchService.saveDiscussPost(post);
    }

}
```

第四步：编写配置类：（QuartzConfig类）

```java
// 刷新帖子分数任务
@Bean
public JobDetailFactoryBean postScoreRefreshJobDetail() {
    JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
    factoryBean.setJobClass(PostScoreRefreshJob.class);
    factoryBean.setName("postScoreRefreshJob");
    factoryBean.setGroup("communityJobGroup");
    factoryBean.setDurability(true);
    factoryBean.setRequestsRecovery(true);
    return factoryBean;
}

@Bean
public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail) {
    SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
    factoryBean.setJobDetail(postScoreRefreshJobDetail);
    factoryBean.setName("postScoreRefreshTrigger");
    factoryBean.setGroup("communityTriggerGroup");
    factoryBean.setRepeatInterval(1000 * 60 * 5);
    factoryBean.setJobDataMap(new JobDataMap());
    return factoryBean;
}
```

第五步：重构查询帖子列表的的dao，service，controller和前端页面

```java
/**
 * 第一个方法是用来做分页查询的
 * @param userId 用户的id，在首页的时候是用不到的，但是在后面的个人主页上面就会有我的帖子里面
 *               就需要使用到这个userId，因此我们在编写sql语句的时候就可以写一个条件判断，
 *               当我们步传入这个数据的时候，这个userId默认就是0，当为0的时候就表示显示全部的数据
 * @param offset 起始页面
 * @param limit 每页显示的条数
 * @param orderMode 排序规则
 * @return 返回值就是所有的帖子对象组成的列表
 */
List<DiscussPost> selectDiscussPosts(int userId, int offset, int limit,int orderMode);
```

```xml
<!--分页查询，显示所有的数据-->
  <!--此时的返回值类型只需要申明泛型即可，而不需要去声明这是一个List集合-->
  <!--List<DiscussPost> selectDiscussPosts(int userId, int offset, int limit);-->
  <select id="selectDiscussPosts" resultType="DiscussPost">
      select <include refid="selectFields" />
      from Discuss_post
      /*2表示的是拉黑的帖子，所以我们不会显示拉黑的帖子*/
      where status != 2
      <!--这里需要有条件判断-->
      <!--
   我们在进行查找的时候可以会传参数，也可能不会传参数，当我们在传参数的时候，就需要将该参数拼接进sql语句中了，
   这个是为了以后的一些功能了，就不需要再进行重新去编写mapper方法和sql语句
-->

      <if test="userId != 0">
          and user_id = #{userId}
      </if>
      /*表示置顶的要放在前面，最新的放在前面*/
      <if test="orderMode==0">
          order by type desc,create_time desc
      </if>
      <if test="orderMode==1">
          order by type desc,score desc,create_time desc
      </if>
      limit #{offset},#{limit}
  </select>
```

```java
/**
 * 分页查询
 * @param userId 用户id
 * @param offset 偏移量
 * @param limit 每页显示的条数
 * @param orderMode 排序规则，按照最新的还是最热的
 * @return 返回List集合
 */
public List<DiscussPost> findDiscussPosts(int userId, int offset, int limit,int orderMode){
    return discussPostMapper.selectDiscussPosts(userId,offset,limit,orderMode);
}
```

```java
/**
 * 跳转到首页的请求
 * @param model model
 * @param page 分页
 * @param orderMode 排序方式，默认为0，表示最新排序
 * @return
 */
@RequestMapping(path = "/index",method = RequestMethod.GET)
public String getIndexPage(Model model, Page page,
                           @RequestParam(value = "orderMode",defaultValue = "0") int orderMode){

    //方法调用前，SpringMVC会自动实例化Model和Page，并将Page注入Model
    //因此在thymeleaf中可以直接访问Page对象中的数据
    //我们在传入数据的时候，只需要传入这两组数据即可，其他的都可以来进行计算得到
    //计算数据的总行数，因为是首页，所以不需要通过userId来进行查询
    page.setRows(discussPostService.findDiscussPostRows(0));
    //写出当前的访问路径
    page.setPath("/index?orderMode=" + orderMode);

    //查询帖子,查询到的字段有id,user_id,title,content,type,status,create_time,comment_count,score
    //但是我们要的不是user_id，我们要的是用户名，因此我们还需要遍历这个帖子，然后根据这个用户id来查询用户名
    List<DiscussPost> list = discussPostService.findDiscussPosts(0, page.getOffset(), page.getLimit(),orderMode);
    //这个集合里面放的是需要前端页面来进行显示的帖子对象和用户对象的map集合
    List<Map<String,Object>> discussPosts = new ArrayList<>();
    if(list != null){
        for(DiscussPost post : list){
            //这里放的就是帖子对象和用户对象
            Map<String,Object> map = new HashMap<>();
            //获取用户对象
            User user = userService.findUserById(post.getUserId());
            //将每一篇帖子对象和用户对象都放到map中
            map.put("post",post);
            map.put("user",user);
            //查询该帖子的点赞的数量
            long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());
            map.put("likeCount", likeCount);
            //把每一篇帖子都放到这个list集合中
            discussPosts.add(map);
        }
    }
    //然后传递给前端
    model.addAttribute("discussPosts",discussPosts);
    model.addAttribute("orderMode",orderMode);
    //返回的是模板的路径，也就是templates下的html文件，这里这个目录下的文件以/开头，后面照着写就行
    return "/index";
}
```

![image-20220627120434740](D:\Typora\File\nowcode_community\image-20220627120434740.png)

### 第八节，生成长图

将网页生成本地的图片

在开发这个功能之前，我们需要下载一个wkhtmltopdf软件，下面对这个软件进行测试

![image-20220627150147987](D:\Typora\File\nowcode_community\image-20220627150147987.png)

![image-20220627150552615](D:\Typora\File\nowcode_community\image-20220627150552615.png)

下面我们来使用java代码来实现该功能：（WkTests类）

```java
public class WkTests {

    public static void main(String[] args) {
        String cmd = "D:/JAVA/tools/wkhtmltopdf/bin/wkhtmltoimage --quality 75  https://www.nowcoder.com  D:/JAVA/tools/wkhtmltopdf/data/wk-images/2.png";
        try {
            Runtime.getRuntime().exec(cmd);
            System.out.println("ok.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

下面开始开发业务

第一步：在配置文件里面实现配置（application.properties）

```properties
# wk
wk.image.command=D:/JAVA/tools/wkhtmltopdf/bin/wkhtmltoimage
wk.image.storage=D:/JAVA/tools/wkhtmltopdf/data/wk-images
```

第二步：创建配置文件，当路径不存在的时候，可以自己创建

```java
@Configuration
public class WkConfig {

    private static final Logger logger = LoggerFactory.getLogger(WkConfig.class);

    @Value("${wk.image.storage}")
    private String wkImageStorage;

    @PostConstruct
    public void init() {
        // 创建WK图片目录
        File file = new File(wkImageStorage);
        if (!file.exists()) {
            file.mkdir();
            logger.info("创建WK图片目录: " + wkImageStorage);
        }
    }
}
```

第三步：编写消费者队列：

```java
@Value("${wk.image.command}")
private String wkImageCommand;

@Value("${wk.image.storage}")
private String wkImageStorage;
// 消费分享事件
@KafkaListener(topics = TOPIC_SHARE)
public void handleShareMessage(ConsumerRecord record) {
    if (record == null || record.value() == null) {
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(), Event.class);
    if (event == null) {
        logger.error("消息格式错误!");
        return;
    }

    String htmlUrl = (String) event.getData().get("htmlUrl");
    String fileName = (String) event.getData().get("fileName");
    String suffix = (String) event.getData().get("suffix");

    String cmd = wkImageCommand + " --quality 75 "
        + htmlUrl + " " + wkImageStorage + "/" + fileName + suffix;
    try {
        Runtime.getRuntime().exec(cmd);
        logger.info("生成长图成功: " + cmd);
    } catch (IOException e) {
        logger.error("生成长图失败: " + e.getMessage());
    }
}
```

第四步：创建controller来处理这个请求

```java
@Controller
public class ShareController implements CommunityConstant {

    private static final Logger logger = LoggerFactory.getLogger(ShareController.class);

    @Autowired
    private EventProducer eventProducer;

    @Value("${community.path.domain}")
    private String domain;

    @Value("${server.servlet.context-path}")
    private String contextPath;

    @Value("${wk.image.storage}")
    private String wkImageStorage;

    @RequestMapping(path = "/share", method = RequestMethod.GET)
    @ResponseBody
    public String share(String htmlUrl) {
        // 文件名
        String fileName = CommunityUtil.generateUUID();

        // 异步生成长图
        Event event = new Event()
                .setTopic(TOPIC_SHARE)
                .setData("htmlUrl", htmlUrl)
                .setData("fileName", fileName)
                .setData("suffix", ".png");
        eventProducer.fireEvent(event);

        // 返回访问路径
        Map<String, Object> map = new HashMap<>();
        map.put("shareUrl", domain + contextPath + "/share/image/" + fileName);

        return CommunityUtil.getJSONString(0, null, map);
    }

    // 获取长图
    @RequestMapping(path = "/share/image/{fileName}", method = RequestMethod.GET)
    public void getShareImage(@PathVariable("fileName") String fileName, HttpServletResponse response) {
        if (StringUtils.isBlank(fileName)) {
            throw new IllegalArgumentException("文件名不能为空!");
        }

        response.setContentType("image/png");
        File file = new File(wkImageStorage + "/" + fileName + ".png");
        try {
            OutputStream os = response.getOutputStream();
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[1024];
            int b = 0;
            while ((b = fis.read(buffer)) != -1) {
                os.write(buffer, 0, b);
            }
        } catch (IOException e) {
            logger.error("获取长图失败: " + e.getMessage());
        }
    }
}
```

最后我们启动程序，然后在地址栏上面写上参数，从而就得到了结果：

![image-20220627154308762](D:\Typora\File\nowcode_community\image-20220627154308762.png)

### 第九节，将文件上传至云服务器

- 客户端上传 
  - 客户端将数据提交给云服务器，并等待其响应。
  - 用户上传头像时，将表单数据提交给云服务器。
- 服务器直传
  - 应用服务器将数据直接提交给云服务器，并等待其响应。
  - 分享时，服务端将自动生成的图片，直接提交给云服务器。

使用七牛云服务器来进行文件上传

第一步：创建七牛云的服务：

![image-20220627223057312](D:\Typora\File\nowcode_community\image-20220627223057312.png)

第二步：导入依赖：

```xml
<!-- https://mvnrepository.com/artifact/com.qiniu/qiniu-java-sdk -->
<dependency>
   <groupId>com.qiniu</groupId>
   <artifactId>qiniu-java-sdk</artifactId>
   <version>7.10.0</version>
</dependency>
```

第三步：配置相关的配置项：

```properties
# qiniu
qiniu.key.access=gCHYGKULsLRa6iRL_m7IuBlkD8nwVVSVomHC1Kaj
qiniu.key.secret=RFFiWpZtBAwVXnBaDsZ1kxyYI6B344UlCSabL2kl
qiniu.bucket.header.name=mia-community-header
quniu.bucket.header.url=http://re543hpz8.hd-bkt.clouddn.com
qiniu.bucket.share.name=mia-community-share
qiniu.bucket.share.url=http://re54tikv3.hd-bkt.clouddn.com
```

第四步：对UserController进行重构

然后废弃掉uploadHeader和getHeader方法

```java
@Value("${qiniu.key.secret}")
private String secretKey;

@Value("${qiniu.bucket.header.name}")
private String headerBucketName;

@Value("${quniu.bucket.header.url}")
private String headerBucketUrl;

/**
 * 从首页跳转到上传头像的页面（setting.html页面）
 * 因为是获取数据，所以需要使用的是get请求
 * @return 跳转到指定的页面
 */
@LoginRequired
@RequestMapping(path = "/setting", method = RequestMethod.GET)
public String getSettingPage(Model model) {

    // 上传文件名称
    String fileName = CommunityUtil.generateUUID();
    // 设置响应信息
    StringMap policy = new StringMap();
    policy.put("returnBody", CommunityUtil.getJSONString(0));
    // 生成上传凭证
    Auth auth = Auth.create(accessKey, secretKey);
    String uploadToken = auth.uploadToken(headerBucketName, fileName, 3600, policy);

    model.addAttribute("uploadToken", uploadToken);
    model.addAttribute("fileName", fileName);

    return "/site/setting";
}

/**
 * 更新头像路径
 * @param fileName 文件名
 * @return
 */
@RequestMapping(path = "/header/url", method = RequestMethod.POST)
@ResponseBody
public String updateHeaderUrl(String fileName) {
    if (StringUtils.isBlank(fileName)) {
        return CommunityUtil.getJSONString(1, "文件名不能为空!");
    }

    String url = headerBucketUrl + "/" + fileName;
    userService.updateHeader(hostHolder.getUser().getId(), url);

    return CommunityUtil.getJSONString(0);
}
```

第五步：对前端页面的进行修改：

setting.js文件

```js
$(function(){
    $("#uploadForm").submit(upload);
});

function upload() {
    $.ajax({
        url: "http://upload.qiniup.com",
        method: "post",
        processData: false,
        contentType: false,
        data: new FormData($("#uploadForm")[0]),
        success: function(data) {
            if(data && data.code == 0) {
                // 更新头像访问路径
                $.post(
                    CONTEXT_PATH + "/user/header/url",
                    {"fileName":$("input[name='key']").val()},
                    function(data) {
                        data = $.parseJSON(data);
                        if(data.code == 0) {
                            window.location.reload();
                        } else {
                            alert(data.msg);
                        }
                    }
                );
            } else {
                alert("上传失败!");
            }
        }
    });
    return false;
}
```

将setting中的头像上传的form表单改为以下内容：

![image-20220627232455396](D:\Typora\File\nowcode_community\image-20220627232455396.png)

这样我们修改的头像的路径就由本地改为七牛云了

下面是分享页面的上传：

在ShareController中废弃掉getShareImage方法，然后重构share方法，将头像的上传交给kafka来做

```java
@Value("${wk.image.storage}")
private String wkImageStorage;

@Value("${qiniu.bucket.share.url}")
private String shareBucketUrl;

@RequestMapping(path = "/share", method = RequestMethod.GET)
@ResponseBody
public String share(String htmlUrl) {
    // 文件名
    String fileName = CommunityUtil.generateUUID();

    // 异步生成长图
    Event event = new Event()
            .setTopic(TOPIC_SHARE)
            .setData("htmlUrl", htmlUrl)
            .setData("fileName", fileName)
            .setData("suffix", ".png");
    eventProducer.fireEvent(event);

    // 返回访问路径
    Map<String, Object> map = new HashMap<>();
    //map.put("shareUrl", domain + contextPath + "/share/image/" + fileName);
    map.put("shareUrl", shareBucketUrl + "/" + fileName);

    return CommunityUtil.getJSONString(0, null, map);
}
```

下一步就是消息消费者的修改了

```java
// 消费分享事件
@KafkaListener(topics = TOPIC_SHARE)
public void handleShareMessage(ConsumerRecord record) {
    if (record == null || record.value() == null) {
        logger.error("消息的内容为空!");
        return;
    }

    Event event = JSONObject.parseObject(record.value().toString(), Event.class);
    if (event == null) {
        logger.error("消息格式错误!");
        return;
    }

    String htmlUrl = (String) event.getData().get("htmlUrl");
    String fileName = (String) event.getData().get("fileName");
    String suffix = (String) event.getData().get("suffix");

    String cmd = wkImageCommand + " --quality 75 "
            + htmlUrl + " " + wkImageStorage + "/" + fileName + suffix;
    try {
        Runtime.getRuntime().exec(cmd);
        logger.info("生成长图成功: " + cmd);
    } catch (IOException e) {
        logger.error("生成长图失败: " + e.getMessage());
    }

    // 启用定时器,监视该图片,一旦生成了,则上传至七牛云.
    UploadTask task = new UploadTask(fileName, suffix);
    Future future = taskScheduler.scheduleAtFixedRate(task, 500);
    task.setFuture(future);
}

class UploadTask implements Runnable {

    // 文件名称
    private String fileName;
    // 文件后缀
    private String suffix;
    // 启动任务的返回值
    private Future future;
    // 开始时间
    private long startTime;
    // 上传次数
    private int uploadTimes;

    public UploadTask(String fileName, String suffix) {
        this.fileName = fileName;
        this.suffix = suffix;
        this.startTime = System.currentTimeMillis();
    }

    public void setFuture(Future future) {
        this.future = future;
    }

    @Override
    public void run() {
        // 生成失败
        if (System.currentTimeMillis() - startTime > 30000) {
            logger.error("执行时间过长,终止任务:" + fileName);
            future.cancel(true);
            return;
        }
        // 上传失败
        if (uploadTimes >= 10) {
            logger.error("上传次数过多,终止任务:" + fileName);
            future.cancel(true);
            return;
        }

        String path = wkImageStorage + "/" + fileName + suffix;
        File file = new File(path);
        if (file.exists()) {
            logger.info(String.format("开始第%d次上传[%s].", ++uploadTimes, fileName));
            // 设置响应信息
            StringMap policy = new StringMap();
            policy.put("returnBody", CommunityUtil.getJSONString(0));
            // 生成上传凭证
            Auth auth = Auth.create(accessKey, secretKey);
            String uploadToken = auth.uploadToken(shareBucketName, fileName, 3600, policy);
            // 指定上传机房
            UploadManager manager = new UploadManager(new Configuration(Zone.huadong()));
            try {
                // 开始上传图片
                Response response = manager.put(
                        path, fileName, uploadToken, null, "image/" + suffix, false);
                // 处理响应结果
                JSONObject json = JSONObject.parseObject(response.bodyString());
                if (json == null || json.get("code") == null || !json.get("code").toString().equals("0")) {
                    logger.info(String.format("第%d次上传失败[%s].", uploadTimes, fileName));
                } else {
                    logger.info(String.format("第%d次上传成功[%s].", uploadTimes, fileName));
                    future.cancel(true);
                }
            } catch (QiniuException e) {
                logger.info(String.format("第%d次上传失败[%s].", uploadTimes, fileName));
            }
        } else {
            logger.info("等待图片生成[" + fileName + "].");
        }
    }
}
```

这样我们就可以对分享的文件进行上传了

### 第十节，优化网站的性能

- 本地缓存
  - 将数据缓存在应用服务器上，性能最好。
  - 常用缓存工具：Ehcache、Guava、Caffeine等。
- 分布式缓存
  - 将数据缓存在NoSQL数据库上，跨服务器。
  - 常用缓存工具：MemCache、Redis等。
- 多级缓存
  - 一级缓存（本地缓存）> 二级缓存（分布式缓存）> DB
  - 避免缓存雪崩（缓存失效，大量请求直达DB ），提高系统的可用性

第一步：添加依赖：

```xml
<!-- https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>2.9.3</version>
</dependency>

```

第二步：编写相关的配置文件：

```properties
# caffeine
caffeine.posts.max-size=15
caffeine.posts.expire-seconds=180
```

第三步：编写service层的帖子列表的初始化（DiscussPostService类）

```java
@Value("${caffeine.posts.max-size}")
private int maxSize;

@Value("${caffeine.posts.expire-seconds}")
private int expireSeconds;

// Caffeine核心接口: Cache, LoadingCache, AsyncLoadingCache

// 帖子列表缓存
private LoadingCache<String, List<DiscussPost>> postListCache;

// 帖子总数缓存
private LoadingCache<Integer, Integer> postRowsCache;

@PostConstruct
public void init() {
    // 初始化帖子列表缓存
    postListCache = Caffeine.newBuilder()
            .maximumSize(maxSize)
            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)
            .build(new CacheLoader<String, List<DiscussPost>>() {
                @Nullable
                @Override
                public List<DiscussPost> load(@NonNull String key) throws Exception {
                    if (key == null || key.length() == 0) {
                        throw new IllegalArgumentException("参数错误!");
                    }

                    String[] params = key.split(":");
                    if (params == null || params.length != 2) {
                        throw new IllegalArgumentException("参数错误!");
                    }

                    int offset = Integer.parseInt(params[0]);
                    int limit = Integer.parseInt(params[1]);

                    // 二级缓存: Redis -> mysql

                    logger.debug("load post list from DB.");
                    return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);
                }
            });
    // 初始化帖子总数缓存
    postRowsCache = Caffeine.newBuilder()
            .maximumSize(maxSize)
            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)
            .build(new CacheLoader<Integer, Integer>() {
                @Nullable
                @Override
                public Integer load(@NonNull Integer key) throws Exception {
                    logger.debug("load post rows from DB.");
                    return discussPostMapper.selectDiscussPostRows(key);
                }
            });
}
```

最后使用jmeter来进行测试即可

## 第8章 项目发布与总结

### 第一节，单元测试

-  Spring Boot Testing 
  - 依赖：spring-boot-starter-test 
  - 包括：Junit、Spring Test、AssertJ、... 
- Test Case 
  - 要求：保证测试方法的独立性。
  - 步骤：初始化数据、执行测试代码、验证测试结果、清理测试数据。
  - 常用注解：@BeforeClass、@AfterClass、@Before、@After。

```java
@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class SpringBootTests {

    @Autowired
    private DiscussPostService discussPostService;

    private DiscussPost data;

    @BeforeClass
    public static void beforeClass() {
        System.out.println("beforeClass");
    }

    @AfterClass
    public static void afterClass() {
        System.out.println("afterClass");
    }

    @Before
    public void before() {
        System.out.println("before");

        // 初始化测试数据
        data = new DiscussPost();
        data.setUserId(111);
        data.setTitle("Test Title");
        data.setContent("Test Content");
        data.setCreateTime(new Date());
        discussPostService.addDiscussPost(data);
    }

    @After
    public void after() {
        System.out.println("after");

        // 删除测试数据
        discussPostService.updateStatus(data.getId(), 2);
    }

    @Test
    public void test1() {
        System.out.println("test1");
    }

    @Test
    public void test2() {
        System.out.println("test2");
    }

    @Test
    public void testFindById() {
        DiscussPost post = discussPostService.findDiscussPostById(data.getId());
        Assert.assertNotNull(post);
        Assert.assertEquals(data.getTitle(), post.getTitle());
        Assert.assertEquals(data.getContent(), post.getContent());
    }

    @Test
    public void testUpdateScore() {
        int rows = discussPostService.updateScore(data.getId(), 2000.00);
        Assert.assertEquals(1, rows);

        DiscussPost post = discussPostService.findDiscussPostById(data.getId());
        Assert.assertEquals(2000.00, post.getScore(), 2);
    }

}
```

### 第二节，项目监控

- Spring Boot Actuator 
  -  Endpoints：监控应用的入口，Spring Boot内置了很多端点，也支持自定义端点。
  -  监控方式：HTTP 或 JMX。
  - 访问路径：例如“/actuator/health”。
  -  注意事项：按需配置暴露的端点，并对所有端点进行权限控制。

第一步：导入依赖：

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator -->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

下面我们来启动一下项目，然后看一下状态：

![image-20220628105343060](D:\Typora\File\nowcode_community\image-20220628105343060.png)



第二步：编写配置文件：

```properties
# actuator
management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=info,caches
```

第三步：编写数据库连接

```java
@Component
@Endpoint(id = "database")
public class DatabaseEndpoint {

    private static final Logger logger = LoggerFactory.getLogger(DatabaseEndpoint.class);

    @Autowired
    private DataSource dataSource;

    @ReadOperation
    public String checkConnection() {
        try (
                Connection conn = dataSource.getConnection();
        ) {
            return CommunityUtil.getJSONString(0, "获取连接成功!");
        } catch (SQLException e) {
            logger.error("获取连接失败:" + e.getMessage());
            return CommunityUtil.getJSONString(1, "获取连接失败!");
        }
    }

}
```

![image-20220628110054312](D:\Typora\File\nowcode_community\image-20220628110054312.png)

最后进行一个权限配置即可。

### 第三节，项目部署

![image-20220628110522437](D:\Typora\File\nowcode_community\image-20220628110522437.png)







### 第四节，项目总结

![image-20220628110710890](D:\Typora\File\nowcode_community\image-20220628110710890.png)





![image-20220628110910946](D:\Typora\File\nowcode_community\image-20220628110910946.png)

### 第五节，常见面试题

#### 1，MySQL 

##### ①存储引擎

![image-20220628111358946](D:\Typora\File\nowcode_community\image-20220628111358946.png)

##### ②事务

- 事务的特性 
  - 原子性:
  - 一致性:
  - 隔离性:
  - 持久性 :
- 事务的隔离性 
- 并发异常：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读 
- 隔离级别：
  - Read Uncommitted:
  - Read Committed:
  - Repeatable Read:
  - Serializable 
- Spring事务管理 
  - 声明式事务:
  -  编程式事务:

##### ③锁

- 范围
  - 表级锁：开销小、加锁快，发生锁冲突的概率高、并发度低，不会出现死锁。 
  - 行级锁：开销大、加锁慢，发生锁冲突的概率低、并发度高，会出现死锁。 
- 类型（InnoDB） 
  - 共享锁（S）：行级，读取一行； 
  - 排他锁（X）：行级，更新一行；
  - 意向共享锁（IS）：表级，准备加共享锁； 
  - 意向排他锁（IX）：表级，准备加排他锁； 
  -  间隙锁（NK）：行级，使用范围条件时， 对范围内不存在的记录加锁。一是为了防止幻读，二是为了满足恢复和复制的需要。

- 加锁 
  - 增加行级锁之前，InnoDB会自动给表加意向锁；
  -  执行DML语句时，InnoDB会自动给数据加排他锁；
  - 执行DQL语句时 
    - 共享锁（S）：SELECT … FROM … WHERE … LOCK IN SHARE MODE; 
    - 排他锁（X）：SELECT … FROM … WHERE … FOR UPDATE;
    -  间隙锁（NK）：上述SQL采用范围条件时，InnoDB对不存在的记录自动增加间隙锁。

- 死锁 
  - 场景 
    - 事务1: UPDATE T SET … WHERE ID = 1; UPDATE T SET … WHERE ID = 2; 
    - 事务2: UPDATE T SET … WHERE ID = 2; UPDATE T SET … WHERE ID = 1; 
  - 解决方案 
    - 1,一般InnoDB会自动检测到，并使一个事务回滚，另一个事务继续； 
    - 2,设置超时等待参数 innodb_lock_wait_timeout； 
  - 避免死锁 
    - 1,不同的业务并发访问多个表时，应约定以相同的顺序来访问这些表；
    - 2,以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理数据； 
    - 3,在事务中，如果要更新记录，应直接申请足够级别的锁，即排他锁；

- 悲观锁（数据库） 
- 乐观锁（自定义） 
  - 1,版本号机制 UPDATE … SET …,VERSION=#{version+1} WHERE … AND VERSION=${version} 
  - 2,CAS算法（Compare and swap） 是一种无锁的算法，该算法涉及3个操作数（内存值V、旧值A、新值B），当V等于A时， 采用原子方式用B的值更新V的值。该算法通常采用自旋操作，也叫自旋锁。它的缺点是： • ABA问题：某线程将A该为B，再改回A，则CAS会误认为A没被修改过。 • 自旋操作采用循环的方式实现，若加锁时间长，则会给CPU带来巨大的开销。 • CAS只能保证一个共享变量的原子操作。

##### ④索引 

B+Tree（InnoDB） 

- • 数据分块存储，每一块称为一页；
-  • 所有的值都是按顺序存储的，并且每一个叶子到根的距离相同； 
- • 非叶节点存储数据的边界，叶子节点存储指向数据行的指针； 
- • 通过边界缩小数据的范围，从而避免全表扫描，加快了查找的速度。

![image-20220628112438209](D:\Typora\File\nowcode_community\image-20220628112438209.png)

#### 2,，Redis 

①数据类型

![image-20220628112528284](D:\Typora\File\nowcode_community\image-20220628112528284.png)

②过期策略

- Redis会把设置了过期时间的key放入一个独立的字典里，在key过期时并不会立刻删除它。 
- Redis会通过如下两种策略，来删除过期的key：
-  惰性删除 
  - 客户端访问某个key时，Redis会检查该key是否过期，若过期则删除。 
- 定期扫描 
  - Redis默认每秒执行10次过期扫描（配置hz选项），扫描策略如下：
    -  1，从过期字典中随机选择20个key；
    - 2， 删除这20个key中已过期的key； 
    - 3，如果过期的key的比例超过25%，则重复步骤1；

③淘汰策略

当Redis占用内存超出最大限制（maxmemory）时，可采用如下策略（maxmemory-policy）， 让Redis淘汰一些数据，以腾出空间继续提供读写服务：

-  noeviction：对可能导致增大内存的命令返回错误（大多数写命令，DEL除外）；
- volatile-ttl：在设置了过期时间的key中，选择剩余寿命（TTL）最短的key，将其淘汰； 
- volatile-lru：在设置了过期时间的key中，选择最少使用的key（LRU），将其淘汰；
- volatile-random：在设置了过期时间的key中，随机选择一些key，将其淘汰；
-  allkeys-lru：在所有的key中，选择最少使用的key（LRU），将其淘汰；
- allkeys-random：在所有的key中，随机选择一些key，将其淘汰；





- LRU算法 
  - 维护一个链表，用于顺序存储被访问过的key。 
  - 在访问数据时，最新访问过的key将被移动到表头， 
  - 即最近访问的key在表头，最少访问的key在表尾。
- 近似LRU算法（Redis） 
  - 给每个key维护一个时间戳，淘汰时随机采样5个key， 从中淘汰掉最旧的key。如果还是超出内存限制，则 继续随机采样淘汰。 
  - 优点：比LRU算法节约内存，却可以取得非常近似的效果。

③缓存穿透

- 场景 
  - 查询根本不存在的数据，使得请求直达存储层， 导致其负载过大，甚至宕机。
-  解决方案 
  - 1，缓存空对象 
    - 存储层未命中后，仍然将空值存入缓存层。
    - 再次访问该数据时，缓存层会直接返回空值。 
  - 2，布隆过滤器 
    - 将所有存在的key提前存入布隆过滤器，在访问缓存层之前， 先通过过滤器拦截，若请求的是不存在的key，则直接返回空值。

![image-20220628113336871](D:\Typora\File\nowcode_community\image-20220628113336871.png)



④缓存击穿

- 场景 
  - 一份热点数据，它的访问量非常大。在其缓存失效瞬间，大量请求直达存储层，导致服务崩溃。 
- 解决方案 
  - 1，加互斥锁 
    - 对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。 这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存取值。 
  - 2，永不过期 
    - 不设置过期时间，所以不会出现上述问题，这是“物理”上的不过期。 为每个value设置逻辑过期时间，当发现该值逻辑过期时，使用单独的线程重建缓存。

⑤缓存雪崩

- 场景 
  - 由于某些原因，缓存层不能提供服务，导致所有的请求直达存储层，造成存储层宕机。
- 解决方案 
  - 1，避免同时过期 设置过期时间时，附加一个随机数，避免大量的key同时过期。 
  - 2，构建高可用的Redis缓存 部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。 
  - 3，构建多级缓存 增加本地缓存，在存储层前面多加一级屏障，降低请求直达存储层的几率。
  -  4，启用限流和降级措施 对存储层增加限流措施，当请求超出限制时，对其提供降级服务。

⑥分布式锁 

- 场景 
  - 修改时，经常需要先将数据读取到内存，在内存中修改后再存回去。在分布式应用中，可能多个进程 同时执行上述操作，而读取和修改非原子操作，所以会产生冲突。增加分布式锁，可以解决此类问题。 
- 基本原理 
  - 同步锁：在多个线程都能访问到的地方，做一个标记，标识该数据的访问权限。 
  - 分布式锁：在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限。 
- 实现方式 
  - 基于数据库实现分布式锁； 
  - 基于Redis实现分布式锁； 
  - 基于Zookeeper实现分布式锁；



- Redis实现分布式锁的原则 
  - 安全属性：独享。在任一时刻，只有一个客户端持有锁。 
  - 活性A：无死锁。即便持有锁的客户端崩溃或者网络被分裂，锁仍然可以被获取。
  - 活性B：容错。只要大部分Redis节点都活着，客户端就可以获取和释放锁。



- 单Redis实例实现分布式锁 
  - 1，获取锁使用命令： 
    - SET resource_name my_random_value NX PX 30000 
    - NX：仅在key不存在时才执行成功。PX：设置锁的自动过期时间。
  - 2，通过Lua脚本释放锁：
    - if redis.call(“get”,KEYS[1]) == ARGV[1] then
    - return redis.call(“del”, KEYS[1]) 
    - else return 0 end 
  - 可以避免删除别的客户端获取成功的锁: A加锁 -> A阻塞 -> 因超时释放锁 -> B加锁 -> A恢复 -> 释放锁

- 多Redis实例实现分布式锁
  -  Redlock算法，该算法有现成的实现，其Java版本的库为Redisson。 
    - 1，获取当前Unix时间，以毫秒为单位。 
    - 2，依次尝试从N个实例，使用相同的key和随机值获取锁，并设置响应超时时间。如果服务器没有在 规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
    - 3，客户端使用当前时间减去开始获取锁的时间，得到获取锁使用的时间。当且仅当大多数的Redis节 点都取到锁，并且使用的时间小于锁失效时间时，锁才算取得成功。 
    -  4，如果取到了锁，key的真正有效时间等于有效时间减去获取锁使用的时间。
    -  5，如果获取锁失败，客户端应该在所有的Redis实例上进行解锁。

#### 3，Spring

#####  ①Spring IoC

Bean的作用域：

![image-20220628114340576](D:\Typora\File\nowcode_community\image-20220628114340576.png)

##### ②Spring AOP

![image-20220628114352448](D:\Typora\File\nowcode_community\image-20220628114352448.png)

##### ③Spring MVC

![image-20220628114406917](D:\Typora\File\nowcode_community\image-20220628114406917.png)
